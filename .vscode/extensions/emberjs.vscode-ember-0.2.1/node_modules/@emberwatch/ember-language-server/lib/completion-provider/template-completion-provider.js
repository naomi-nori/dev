"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const vscode_languageserver_1 = require("vscode-languageserver");
const glimmer_utils_1 = require("../glimmer-utils");
const estree_utils_1 = require("../estree-utils");
const fuzzaldrin_1 = require("fuzzaldrin");
const { preprocess } = require('@glimmer/syntax');
const ember_helpers_1 = require("./ember-helpers");
const unique_by_1 = require("../utils/unique-by");
const file_extension_1 = require("../utils/file-extension");
const walkSync = require('walk-sync');
class TemplateCompletionProvider {
    constructor(server) {
        this.server = server;
    }
    provideCompletions(params) {
        const uri = params.textDocument.uri;
        if (file_extension_1.getExtension(params.textDocument) !== '.hbs') {
            return [];
        }
        const project = this.server.projectRoots.projectForUri(uri);
        if (!project) {
            return [];
        }
        let document = this.server.documents.get(uri);
        let offset = document.offsetAt(params.position);
        let originalText = document.getText();
        let text = originalText.slice(0, offset) + 'ELSCompletionDummy' + originalText.slice(offset);
        let ast = preprocess(text);
        let focusPath = glimmer_utils_1.default.toPosition(ast, estree_utils_1.toPosition(params.position));
        if (!focusPath) {
            return [];
        }
        const { root } = project;
        let completions = [];
        if (isMustachePath(focusPath)) {
            completions.push(...listComponents(root));
            completions.push(...listHelpers(root));
            completions.push(...ember_helpers_1.emberMustacheItems);
        }
        else if (isBlockPath(focusPath)) {
            completions.push(...listComponents(root));
            completions.push(...ember_helpers_1.emberBlockItems);
        }
        else if (isSubExpressionPath(focusPath)) {
            completions.push(...listHelpers(root));
            completions.push(...ember_helpers_1.emberSubExpressionItems);
        }
        else if (isLinkToTarget(focusPath)) {
            completions.push(...listRoutes(root));
        }
        return fuzzaldrin_1.filter(completions, getTextPrefix(focusPath), { key: 'label' });
    }
}
exports.default = TemplateCompletionProvider;
function listComponents(root) {
    const jsPaths = walkSync(path_1.join(root, 'app', 'components'), {
        directories: false,
        globs: ['**/*.js']
    });
    const hbsPaths = walkSync(path_1.join(root, 'app', 'templates', 'components'), {
        directories: false,
        globs: ['**/*.hbs']
    });
    const paths = [...jsPaths, ...hbsPaths];
    const items = paths
        .map((filePath) => {
        return {
            kind: vscode_languageserver_1.CompletionItemKind.Class,
            label: filePath.replace(path_1.extname(filePath), ''),
            detail: 'component',
        };
    });
    return unique_by_1.default(items, 'label');
}
function listHelpers(root) {
    const paths = walkSync(path_1.join(root, 'app', 'helpers'), {
        directories: false,
        globs: ['**/*.js']
    });
    const items = paths
        .map((filePath) => {
        return {
            kind: vscode_languageserver_1.CompletionItemKind.Function,
            label: filePath.replace(path_1.extname(filePath), ''),
            detail: 'helper',
        };
    });
    return unique_by_1.default(items, 'label');
}
function listRoutes(root) {
    const paths = walkSync(path_1.join(root, 'app', 'routes'), {
        directories: false,
        globs: ['**/*.js']
    });
    const items = paths
        .map((filePath) => {
        const label = filePath
            .replace(path_1.extname(filePath), '')
            .replace(/\//g, '.');
        return {
            kind: vscode_languageserver_1.CompletionItemKind.File,
            label,
            detail: 'route',
        };
    });
    return unique_by_1.default(items, 'label');
}
function isMustachePath(path) {
    let node = path.node;
    if (node.type !== 'PathExpression') {
        return false;
    }
    let parent = path.parent;
    if (!parent || parent.type !== 'MustacheStatement') {
        return false;
    }
    return parent.path === node;
}
function isBlockPath(path) {
    let node = path.node;
    if (node.type !== 'PathExpression') {
        return false;
    }
    let parent = path.parent;
    if (!parent || parent.type !== 'BlockStatement') {
        return false;
    }
    return parent.path === node;
}
function isSubExpressionPath(path) {
    let node = path.node;
    if (node.type !== 'PathExpression') {
        return false;
    }
    let parent = path.parent;
    if (!parent || parent.type !== 'SubExpression') {
        return false;
    }
    return parent.path === node;
}
function isLinkToTarget(path) {
    return isInlineLinkToTarget(path) || isBlockLinkToTarget(path);
}
function isInlineLinkToTarget(path) {
    let node = path.node;
    if (node.type !== 'StringLiteral') {
        return false;
    }
    let parent = path.parent;
    if (!parent || parent.type !== 'MustacheStatement') {
        return false;
    }
    return parent.params[1] === node && parent.path.original === 'link-to';
}
function isBlockLinkToTarget(path) {
    let node = path.node;
    if (node.type !== 'StringLiteral') {
        return false;
    }
    let parent = path.parent;
    if (!parent || parent.type !== 'BlockStatement') {
        return false;
    }
    return parent.params[0] === node && parent.path.original === 'link-to';
}
function getTextPrefix({ node: { original = '' } }) {
    return original.replace('ELSCompletionDummy', '');
}
//# sourceMappingURL=template-completion-provider.js.map