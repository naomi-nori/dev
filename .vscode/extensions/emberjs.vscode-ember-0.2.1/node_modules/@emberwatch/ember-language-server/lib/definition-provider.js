"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const vscode_languageserver_1 = require("vscode-languageserver");
const babylon_1 = require("babylon");
const estree_utils_1 = require("./estree-utils");
const glimmer_utils_1 = require("./glimmer-utils");
const file_extension_1 = require("./utils/file-extension");
const vscode_uri_1 = require("vscode-uri");
const { preprocess } = require('@glimmer/syntax');
class DefinitionProvider {
    constructor(server) {
        this.server = server;
    }
    handle(params) {
        let uri = params.textDocument.uri;
        const project = this.server.projectRoots.projectForUri(uri);
        if (!project) {
            return null;
        }
        let extension = file_extension_1.getExtension(params.textDocument);
        if (extension === '.hbs') {
            let content = this.server.documents.get(uri).getText();
            let ast = preprocess(content);
            let focusPath = glimmer_utils_1.default.toPosition(ast, estree_utils_1.toPosition(params.position));
            if (!focusPath) {
                return null;
            }
            if (this.isComponentOrHelperName(focusPath)) {
                const componentOrHelperName = focusPath.node.original;
                const templatePath = path.join(project.root, 'app', 'components', `${componentOrHelperName}.js`);
                const componentPath = path.join(project.root, 'app', 'templates', 'components', `${componentOrHelperName}.hbs`);
                const helperPath = path.join(project.root, 'app', 'helpers', `${componentOrHelperName}.js`);
                return pathsToLocations(templatePath, componentPath, helperPath);
            }
        }
        else if (extension === '.js') {
            let content = this.server.documents.get(uri).getText();
            let ast = babylon_1.parse(content, {
                sourceType: 'module'
            });
            let astPath = glimmer_utils_1.default.toPosition(ast, estree_utils_1.toPosition(params.position));
            if (!astPath) {
                return null;
            }
            if (isModelReference(astPath)) {
                let modelName = astPath.node.value;
                const modelPath = path.join(project.root, 'app', 'models', `${modelName}.js`);
                return pathsToLocations(modelPath);
            }
            else if (isTransformReference(astPath)) {
                let transformName = astPath.node.value;
                const transformPath = path.join(project.root, 'app', 'transforms', `${transformName}.js`);
                return pathsToLocations(transformPath);
            }
        }
        return null;
    }
    get handler() {
        return this.handle.bind(this);
    }
    isComponentOrHelperName(path) {
        let node = path.node;
        if (node.type !== 'PathExpression') {
            return false;
        }
        let parent = path.parent;
        if (!parent || parent.path !== node || (parent.type !== 'MustacheStatement' && parent.type !== 'BlockStatement')) {
            return false;
        }
        return true;
    }
}
exports.default = DefinitionProvider;
function isModelReference(astPath) {
    let node = astPath.node;
    if (node.type !== 'StringLiteral') {
        return false;
    }
    let parent = astPath.parent;
    if (!parent || parent.type !== 'CallExpression' || parent.arguments[0] !== node) {
        return false;
    }
    let identifier = (parent.callee.type === 'Identifier') ? parent.callee : parent.callee.property;
    return identifier.name === 'belongsTo' || identifier.name === 'hasMany';
}
function isTransformReference(astPath) {
    let node = astPath.node;
    if (node.type !== 'StringLiteral') {
        return false;
    }
    let parent = astPath.parent;
    if (!parent || parent.type !== 'CallExpression' || parent.arguments[0] !== node) {
        return false;
    }
    let identifier = (parent.callee.type === 'Identifier') ? parent.callee : parent.callee.property;
    return identifier.name === 'attr';
}
function pathsToLocations(...paths) {
    return paths
        .filter(fs.existsSync)
        .map(modulePath => {
        return vscode_languageserver_1.Location.create(vscode_uri_1.default.file(modulePath).toString(), vscode_languageserver_1.Range.create(0, 0, 0, 0));
    });
}
//# sourceMappingURL=definition-provider.js.map