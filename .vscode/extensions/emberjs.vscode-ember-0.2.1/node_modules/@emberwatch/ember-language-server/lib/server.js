/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const vscode_languageserver_1 = require("vscode-languageserver");
const project_roots_1 = require("./project-roots");
const definition_provider_1 = require("./definition-provider");
const template_linter_1 = require("./template-linter");
const js_document_symbol_provider_1 = require("./symbols/js-document-symbol-provider");
const hbs_document_symbol_provider_1 = require("./symbols/hbs-document-symbol-provider");
const template_completion_provider_1 = require("./completion-provider/template-completion-provider");
const files_1 = require("vscode-languageserver/lib/files");
class Server {
    constructor() {
        // Create a connection for the server. The connection uses Node's IPC as a transport
        this.connection = vscode_languageserver_1.createConnection(new vscode_languageserver_1.IPCMessageReader(process), new vscode_languageserver_1.IPCMessageWriter(process));
        // Create a simple text document manager. The text document manager
        // supports full document sync only
        this.documents = new vscode_languageserver_1.TextDocuments();
        this.projectRoots = new project_roots_1.default();
        this.documentSymbolProviders = [
            new js_document_symbol_provider_1.default(),
            new hbs_document_symbol_provider_1.default(),
        ];
        this.templateCompletionProvider = new template_completion_provider_1.default(this);
        this.definitionProvider = new definition_provider_1.default(this);
        this.templateLinter = new template_linter_1.default(this);
        // Make the text document manager listen on the connection
        // for open, change and close text document events
        this.documents.listen(this.connection);
        // Bind event handlers
        this.connection.onInitialize(this.onInitialize.bind(this));
        this.documents.onDidChangeContent(this.onDidChangeContent.bind(this));
        this.connection.onDidChangeWatchedFiles(this.onDidChangeWatchedFiles.bind(this));
        this.connection.onDocumentSymbol(this.onDocumentSymbol.bind(this));
        this.connection.onDefinition(this.definitionProvider.handler);
        this.connection.onCompletion(this.onCompletion.bind(this));
    }
    listen() {
        this.connection.listen();
    }
    // After the server has started the client sends an initilize request. The server receives
    // in the passed params the rootPath of the workspace plus the client capabilites.
    onInitialize({ rootUri, rootPath }) {
        rootPath = rootUri ? files_1.uriToFilePath(rootUri) : rootPath;
        if (!rootPath) {
            return { capabilities: {} };
        }
        console.log(`Initializing Ember Language Server at ${rootPath}`);
        this.projectRoots.initialize(rootPath);
        return {
            capabilities: {
                // Tell the client that the server works in FULL text document sync mode
                textDocumentSync: this.documents.syncKind,
                definitionProvider: true,
                documentSymbolProvider: true,
                completionProvider: {
                    resolveProvider: true
                }
            }
        };
    }
    onDidChangeContent(change) {
        this.templateLinter.lint(change.document);
    }
    onDidChangeWatchedFiles() {
        // here be dragons
    }
    onCompletion(textDocumentPosition) {
        const completionItems = [];
        const templateCompletions = this.templateCompletionProvider.provideCompletions(textDocumentPosition);
        completionItems.push(...templateCompletions);
        return completionItems;
    }
    onDocumentSymbol(params) {
        let uri = params.textDocument.uri;
        let filePath = files_1.uriToFilePath(uri);
        if (!filePath) {
            return [];
        }
        let extension = path_1.extname(filePath);
        let providers = this.documentSymbolProviders
            .filter(provider => provider.extensions.indexOf(extension) !== -1);
        if (providers.length === 0)
            return [];
        let content = fs_1.readFileSync(filePath, 'utf-8');
        return providers
            .map(providers => providers.process(content))
            .reduce((a, b) => a.concat(b), []);
    }
}
exports.default = Server;
//# sourceMappingURL=server.js.map