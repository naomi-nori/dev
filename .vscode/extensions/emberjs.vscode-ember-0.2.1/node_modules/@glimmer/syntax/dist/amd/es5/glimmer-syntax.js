define('@glimmer/syntax', ['exports', 'simple-html-tokenizer', '@glimmer/util', 'handlebars'], function (exports, simpleHtmlTokenizer, util, handlebars) { 'use strict';

function isCall(node) {
    return node.type === 'SubExpression' || node.type === 'MustacheStatement' && node.path.type === 'PathExpression';
}
function isLiteral(input) {
    return !!(typeof input === 'object' && input.type.match(/Literal$/));
}


var nodes = Object.freeze({
	isCall: isCall,
	isLiteral: isLiteral
});

function buildMustache(path, params, hash, raw, loc) {
    if (!isLiteral(path)) {
        path = buildPath(path);
    }
    return {
        type: 'MustacheStatement',
        path: path,
        params: params || [],
        hash: hash || buildHash([]),
        escaped: !raw,
        loc: buildLoc(loc || null)
    };
}
function buildBlock(path, params, hash, program, inverse, loc) {
    return {
        type: 'BlockStatement',
        path: buildPath(path),
        params: params || [],
        hash: hash || buildHash([]),
        program: program || null,
        inverse: inverse || null,
        loc: buildLoc(loc || null)
    };
}
function buildElementModifier(path, params, hash, loc) {
    return {
        type: 'ElementModifierStatement',
        path: buildPath(path),
        params: params || [],
        hash: hash || buildHash([]),
        loc: buildLoc(loc || null)
    };
}
function buildPartial(name, params, hash, indent, loc) {
    return {
        type: 'PartialStatement',
        name: name,
        params: params || [],
        hash: hash || buildHash([]),
        indent: indent || '',
        strip: { open: false, close: false },
        loc: buildLoc(loc || null)
    };
}
function buildComment(value, loc) {
    return {
        type: 'CommentStatement',
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildMustacheComment(value, loc) {
    return {
        type: 'MustacheCommentStatement',
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildConcat(parts, loc) {
    return {
        type: 'ConcatStatement',
        parts: parts || [],
        loc: buildLoc(loc || null)
    };
}
function buildElement(tag, attributes, modifiers, children, comments, loc) {
    // this is used for backwards compat prior to `comments` being added to the AST
    if (!Array.isArray(comments)) {
        loc = comments;
        comments = [];
    }
    // this is used for backwards compat, prior to `selfClosing` being part of the ElementNode AST
    var selfClosing = false;
    if (typeof tag === 'object') {
        selfClosing = tag.selfClosing;
        tag = tag.name;
    }
    return {
        type: 'ElementNode',
        tag: tag || '',
        selfClosing: selfClosing,
        attributes: attributes || [],
        blockParams: [],
        modifiers: modifiers || [],
        comments: comments || [],
        children: children || [],
        loc: buildLoc(loc || null)
    };
}
function buildAttr(name, value, loc) {
    return {
        type: 'AttrNode',
        name: name,
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildText(chars, loc) {
    return {
        type: 'TextNode',
        chars: chars || '',
        loc: buildLoc(loc || null)
    };
}
// Expressions
function buildSexpr(path, params, hash, loc) {
    return {
        type: 'SubExpression',
        path: buildPath(path),
        params: params || [],
        hash: hash || buildHash([]),
        loc: buildLoc(loc || null)
    };
}
function buildPath(original, loc) {
    if (typeof original !== 'string') return original;
    var parts = original.split('.');
    var thisHead = false;
    if (parts[0] === 'this') {
        thisHead = true;
        parts = parts.slice(1);
    }
    return {
        type: 'PathExpression',
        original: original,
        this: thisHead,
        parts: parts,
        data: false,
        loc: buildLoc(loc || null)
    };
}
function buildLiteral(type, value, loc) {
    return {
        type: type,
        value: value,
        original: value,
        loc: buildLoc(loc || null)
    };
}
// Miscellaneous
function buildHash(pairs, loc) {
    return {
        type: 'Hash',
        pairs: pairs || [],
        loc: buildLoc(loc || null)
    };
}
function buildPair(key, value, loc) {
    return {
        type: 'HashPair',
        key: key,
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildProgram(body, blockParams, loc) {
    return {
        type: 'Program',
        body: body || [],
        blockParams: blockParams || [],
        loc: buildLoc(loc || null)
    };
}
function buildSource(source) {
    return source || null;
}
function buildPosition(line, column) {
    return {
        line: line,
        column: column
    };
}
var SYNTHETIC = {
    source: '(synthetic)',
    start: { line: 1, column: 0 },
    end: { line: 1, column: 0 }
};
function buildLoc() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    if (args.length === 1) {
        var loc = args[0];
        if (loc && typeof loc === 'object') {
            return {
                source: buildSource(loc.source),
                start: buildPosition(loc.start.line, loc.start.column),
                end: buildPosition(loc.end.line, loc.end.column)
            };
        } else {
            return SYNTHETIC;
        }
    } else {
        var startLine = args[0],
            startColumn = args[1],
            endLine = args[2],
            endColumn = args[3],
            source = args[4];

        return {
            source: buildSource(source),
            start: buildPosition(startLine, startColumn),
            end: buildPosition(endLine, endColumn)
        };
    }
}
var b = {
    mustache: buildMustache,
    block: buildBlock,
    partial: buildPartial,
    comment: buildComment,
    mustacheComment: buildMustacheComment,
    element: buildElement,
    elementModifier: buildElementModifier,
    attr: buildAttr,
    text: buildText,
    sexpr: buildSexpr,
    path: buildPath,
    concat: buildConcat,
    hash: buildHash,
    pair: buildPair,
    literal: buildLiteral,
    program: buildProgram,
    loc: buildLoc,
    pos: buildPosition,
    string: literal('StringLiteral'),
    boolean: literal('BooleanLiteral'),
    number: literal('NumberLiteral'),
    undefined: function (_undefined) {
        function undefined() {
            return _undefined.apply(this, arguments);
        }

        undefined.toString = function () {
            return _undefined.toString();
        };

        return undefined;
    }(function () {
        return buildLiteral('UndefinedLiteral', undefined);
    }),
    null: function _null() {
        return buildLiteral('NullLiteral', null);
    }
};
function literal(type) {
    return function (value) {
        return buildLiteral(type, value);
    };
}

/**
 * Subclass of `Error` with additional information
 * about location of incorrect markup.
 */
var SyntaxError = function () {
    SyntaxError.prototype = Object.create(Error.prototype);
    SyntaxError.prototype.constructor = SyntaxError;
    function SyntaxError(message, location) {
        var error = Error.call(this, message);
        this.message = message;
        this.stack = error.stack;
        this.location = location;
    }
    return SyntaxError;
}();

// Regex to validate the identifier for block parameters.
// Based on the ID validation regex in Handlebars.
var ID_INVERSE_PATTERN = /[!"#%-,\.\/;->@\[-\^`\{-~]/;
// Checks the element's attributes to see if it uses block params.
// If it does, registers the block params with the program and
// removes the corresponding attributes from the element.
function parseElementBlockParams(element) {
    var params = parseBlockParams(element);
    if (params) element.blockParams = params;
}
function parseBlockParams(element) {
    var l = element.attributes.length;
    var attrNames = [];
    for (var i = 0; i < l; i++) {
        attrNames.push(element.attributes[i].name);
    }
    var asIndex = attrNames.indexOf('as');
    if (asIndex !== -1 && l > asIndex && attrNames[asIndex + 1].charAt(0) === '|') {
        // Some basic validation, since we're doing the parsing ourselves
        var paramsString = attrNames.slice(asIndex).join(' ');
        if (paramsString.charAt(paramsString.length - 1) !== '|' || paramsString.match(/\|/g).length !== 2) {
            throw new SyntaxError("Invalid block parameters syntax: '" + paramsString + "'", element.loc);
        }
        var params = [];
        for (var _i = asIndex + 1; _i < l; _i++) {
            var param = attrNames[_i].replace(/\|/g, '');
            if (param !== '') {
                if (ID_INVERSE_PATTERN.test(param)) {
                    throw new SyntaxError("Invalid identifier for block parameters: '" + param + "' in '" + paramsString + "'", element.loc);
                }
                params.push(param);
            }
        }
        if (params.length === 0) {
            throw new SyntaxError("Cannot use zero block parameters: '" + paramsString + "'", element.loc);
        }
        element.attributes = element.attributes.slice(0, asIndex);
        return params;
    }
    return null;
}
function childrenFor(node) {
    switch (node.type) {
        case 'Program':
            return node.body;
        case 'ElementNode':
            return node.children;
    }
}
function appendChild(parent, node) {
    childrenFor(parent).push(node);
}
function isLiteral$1(path) {
    return path.type === 'StringLiteral' || path.type === 'BooleanLiteral' || path.type === 'NumberLiteral' || path.type === 'NullLiteral' || path.type === 'UndefinedLiteral';
}
function printLiteral(literal) {
    if (literal.type === 'UndefinedLiteral') {
        return 'undefined';
    } else {
        return JSON.stringify(literal.value);
    }
}

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var entityParser = new simpleHtmlTokenizer.EntityParser(simpleHtmlTokenizer.HTML5NamedCharRefs);
var Parser = function () {
    function Parser(source) {
        _classCallCheck$2(this, Parser);

        this.elementStack = [];
        this.currentAttribute = null;
        this.currentNode = null;
        this.tokenizer = new simpleHtmlTokenizer.EventedTokenizer(this, entityParser);
        this.source = source.split(/(?:\r\n?|\n)/g);
    }

    Parser.prototype.acceptNode = function acceptNode(node) {
        return this[node.type](node);
    };

    Parser.prototype.currentElement = function currentElement() {
        return this.elementStack[this.elementStack.length - 1];
    };

    Parser.prototype.sourceForNode = function sourceForNode(node, endNode) {
        var firstLine = node.loc.start.line - 1;
        var currentLine = firstLine - 1;
        var firstColumn = node.loc.start.column;
        var string = [];
        var line = void 0;
        var lastLine = void 0;
        var lastColumn = void 0;
        if (endNode) {
            lastLine = endNode.loc.end.line - 1;
            lastColumn = endNode.loc.end.column;
        } else {
            lastLine = node.loc.end.line - 1;
            lastColumn = node.loc.end.column;
        }
        while (currentLine < lastLine) {
            currentLine++;
            line = this.source[currentLine];
            if (currentLine === firstLine) {
                if (firstLine === lastLine) {
                    string.push(line.slice(firstColumn, lastColumn));
                } else {
                    string.push(line.slice(firstColumn));
                }
            } else if (currentLine === lastLine) {
                string.push(line.slice(0, lastColumn));
            } else {
                string.push(line);
            }
        }
        return string.join('\n');
    };

    _createClass(Parser, [{
        key: 'currentAttr',
        get: function get() {
            return this.currentAttribute;
        }
    }, {
        key: 'currentTag',
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }, {
        key: 'currentStartTag',
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }, {
        key: 'currentEndTag',
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }, {
        key: 'currentComment',
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }, {
        key: 'currentData',
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }]);

    return Parser;
}();

function _defaults$1(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults$1(subClass, superClass); }

var HandlebarsNodeVisitors = function (_Parser) {
    _inherits$1(HandlebarsNodeVisitors, _Parser);

    function HandlebarsNodeVisitors() {
        _classCallCheck$1(this, HandlebarsNodeVisitors);

        var _this = _possibleConstructorReturn$1(this, _Parser.apply(this, arguments));

        _this.cursorCount = 0;
        return _this;
    }

    HandlebarsNodeVisitors.prototype.cursor = function cursor() {
        return '%cursor:' + this.cursorCount++ + '%';
    };

    HandlebarsNodeVisitors.prototype.Program = function Program(program) {
        var body = [];
        this.cursorCount = 0;
        var node = b.program(body, program.blockParams, program.loc);
        var i = void 0,
            l = program.body.length;
        this.elementStack.push(node);
        if (l === 0) {
            return this.elementStack.pop();
        }
        for (i = 0; i < l; i++) {
            this.acceptNode(program.body[i]);
        }
        // Ensure that that the element stack is balanced properly.
        var poppedNode = this.elementStack.pop();
        if (poppedNode !== node) {
            var elementNode = poppedNode;
            throw new SyntaxError('Unclosed element `' + elementNode.tag + '` (on line ' + elementNode.loc.start.line + ').', elementNode.loc);
        }
        return node;
    };

    HandlebarsNodeVisitors.prototype.BlockStatement = function BlockStatement(block) {
        if (this.tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(block));
            return;
        }
        if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {
            throw new SyntaxError('A block may only be used inside an HTML element or another block.', block.loc);
        }

        var _acceptCallNodes = acceptCallNodes(this, block),
            path = _acceptCallNodes.path,
            params = _acceptCallNodes.params,
            hash = _acceptCallNodes.hash;

        var program = this.Program(block.program);
        var inverse = block.inverse ? this.Program(block.inverse) : null;
        if (path.original === 'in-element') {
            hash = addInElementHash(this.cursor(), hash, block.loc);
        }
        var node = b.block(path, params, hash, program, inverse, block.loc);
        var parentProgram = this.currentElement();
        appendChild(parentProgram, node);
    };

    HandlebarsNodeVisitors.prototype.MustacheStatement = function MustacheStatement(rawMustache) {
        var tokenizer = this.tokenizer;

        if (tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawMustache));
            return;
        }
        var mustache = void 0;
        var escaped = rawMustache.escaped,
            loc = rawMustache.loc;

        if (rawMustache.path.type.match(/Literal$/)) {
            mustache = {
                type: 'MustacheStatement',
                path: this.acceptNode(rawMustache.path),
                params: [],
                hash: b.hash(),
                escaped: escaped,
                loc: loc
            };
        } else {
            var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
                path = _acceptCallNodes2.path,
                params = _acceptCallNodes2.params,
                hash = _acceptCallNodes2.hash;

            mustache = b.mustache(path, params, hash, !escaped, loc);
        }
        switch (tokenizer.state) {
            // Tag helpers
            case "tagName" /* tagName */:
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            case "beforeAttributeName" /* beforeAttributeName */:
                addElementModifier(this.currentStartTag, mustache);
                break;
            case "attributeName" /* attributeName */:
            case "afterAttributeName" /* afterAttributeName */:
                this.beginAttributeValue(false);
                this.finishAttributeValue();
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            case "afterAttributeValueQuoted" /* afterAttributeValueQuoted */:
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            // Attribute values
            case "beforeAttributeValue" /* beforeAttributeValue */:
                this.beginAttributeValue(false);
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                tokenizer.transitionTo("attributeValueUnquoted" /* attributeValueUnquoted */);
                break;
            case "attributeValueDoubleQuoted" /* attributeValueDoubleQuoted */:
            case "attributeValueSingleQuoted" /* attributeValueSingleQuoted */:
            case "attributeValueUnquoted" /* attributeValueUnquoted */:
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                break;
            // TODO: Only append child when the tokenizer state makes
            // sense to do so, otherwise throw an error.
            default:
                appendChild(this.currentElement(), mustache);
        }
        return mustache;
    };

    HandlebarsNodeVisitors.prototype.ContentStatement = function ContentStatement(content) {
        updateTokenizerLocation(this.tokenizer, content);
        this.tokenizer.tokenizePart(content.value);
        this.tokenizer.flushData();
    };

    HandlebarsNodeVisitors.prototype.CommentStatement = function CommentStatement(rawComment) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === "comment" /* comment */) {
                this.appendToCommentData(this.sourceForNode(rawComment));
                return null;
            }
        var value = rawComment.value,
            loc = rawComment.loc;

        var comment = b.mustacheComment(value, loc);
        switch (tokenizer.state) {
            case "beforeAttributeName" /* beforeAttributeName */:
                this.currentStartTag.comments.push(comment);
                break;
            case "beforeData" /* beforeData */:
            case "data" /* data */:
                appendChild(this.currentElement(), comment);
                break;
            default:
                throw new SyntaxError('Using a Handlebars comment when in the `' + tokenizer['state'] + '` state is not supported: "' + comment.value + '" on line ' + loc.start.line + ':' + loc.start.column, rawComment.loc);
        }
        return comment;
    };

    HandlebarsNodeVisitors.prototype.PartialStatement = function PartialStatement(partial) {
        var loc = partial.loc;

        throw new SyntaxError('Handlebars partials are not supported: "' + this.sourceForNode(partial, partial.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partial.loc);
    };

    HandlebarsNodeVisitors.prototype.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
        var loc = partialBlock.loc;

        throw new SyntaxError('Handlebars partial blocks are not supported: "' + this.sourceForNode(partialBlock, partialBlock.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partialBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.Decorator = function Decorator(decorator) {
        var loc = decorator.loc;

        throw new SyntaxError('Handlebars decorators are not supported: "' + this.sourceForNode(decorator, decorator.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decorator.loc);
    };

    HandlebarsNodeVisitors.prototype.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
        var loc = decoratorBlock.loc;

        throw new SyntaxError('Handlebars decorator blocks are not supported: "' + this.sourceForNode(decoratorBlock, decoratorBlock.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decoratorBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.SubExpression = function SubExpression(sexpr) {
        var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
            path = _acceptCallNodes3.path,
            params = _acceptCallNodes3.params,
            hash = _acceptCallNodes3.hash;

        return b.sexpr(path, params, hash, sexpr.loc);
    };

    HandlebarsNodeVisitors.prototype.PathExpression = function PathExpression(path) {
        var original = path.original,
            loc = path.loc;

        var parts = void 0;
        if (original.indexOf('/') !== -1) {
            if (original.slice(0, 2) === './') {
                throw new SyntaxError('Using "./" is not supported in Glimmer and unnecessary: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.slice(0, 3) === '../') {
                throw new SyntaxError('Changing context using "../" is not supported in Glimmer: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.indexOf('.') !== -1) {
                throw new SyntaxError('Mixing \'.\' and \'/\' in paths is not supported in Glimmer; use only \'.\' to separate property paths: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            parts = [path.parts.join('/')];
        } else {
            parts = path.parts;
        }
        var thisHead = false;
        // This is to fix a bug in the Handlebars AST where the path expressions in
        // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
        // are simply turned into `{{foo}}`. The fix is to push it back onto the
        // parts array and let the runtime see the difference. However, we cannot
        // simply use the string `this` as it means literally the property called
        // "this" in the current context (it can be expressed in the syntax as
        // `{{[this]}}`, where the square bracket are generally for this kind of
        // escaping â€“ such as `{{foo.["bar.baz"]}}` would mean lookup a property
        // named literally "bar.baz" on `this.foo`). By convention, we use `null`
        // for this purpose.
        if (original.match(/^this(\..+)?$/)) {
            thisHead = true;
        }
        return {
            type: 'PathExpression',
            original: path.original,
            this: thisHead,
            parts: parts,
            data: path.data,
            loc: path.loc
        };
    };

    HandlebarsNodeVisitors.prototype.Hash = function Hash(hash) {
        var pairs = [];
        for (var i = 0; i < hash.pairs.length; i++) {
            var pair = hash.pairs[i];
            pairs.push(b.pair(pair.key, this.acceptNode(pair.value), pair.loc));
        }
        return b.hash(pairs, hash.loc);
    };

    HandlebarsNodeVisitors.prototype.StringLiteral = function StringLiteral(string) {
        return b.literal('StringLiteral', string.value, string.loc);
    };

    HandlebarsNodeVisitors.prototype.BooleanLiteral = function BooleanLiteral(boolean) {
        return b.literal('BooleanLiteral', boolean.value, boolean.loc);
    };

    HandlebarsNodeVisitors.prototype.NumberLiteral = function NumberLiteral(number) {
        return b.literal('NumberLiteral', number.value, number.loc);
    };

    HandlebarsNodeVisitors.prototype.UndefinedLiteral = function UndefinedLiteral(undef) {
        return b.literal('UndefinedLiteral', undefined, undef.loc);
    };

    HandlebarsNodeVisitors.prototype.NullLiteral = function NullLiteral(nul) {
        return b.literal('NullLiteral', null, nul.loc);
    };

    return HandlebarsNodeVisitors;
}(Parser);
function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
        // if it is empty, just return the count of newlines
        // in original
        return {
            lines: original.split('\n').length - 1,
            columns: 0
        };
    }
    // otherwise, return the number of newlines prior to
    // `value`
    var difference = original.split(value)[0];
    var lines = difference.split(/\n/);
    var lineCount = lines.length - 1;
    return {
        lines: lineCount,
        columns: lines[lineCount].length
    };
}
function updateTokenizerLocation(tokenizer, content) {
    var line = content.loc.start.line;
    var column = content.loc.start.column;
    var offsets = calculateRightStrippedOffsets(content.original, content.value);
    line = line + offsets.lines;
    if (offsets.lines) {
        column = offsets.columns;
    } else {
        column = column + offsets.columns;
    }
    tokenizer.line = line;
    tokenizer.column = column;
}
function acceptCallNodes(compiler, node) {
    var path = compiler.PathExpression(node.path);
    var params = node.params ? node.params.map(function (e) {
        return compiler.acceptNode(e);
    }) : [];
    var hash = node.hash ? compiler.Hash(node.hash) : b.hash();
    return { path: path, params: params, hash: hash };
}
function addElementModifier(element, mustache) {
    var path = mustache.path,
        params = mustache.params,
        hash = mustache.hash,
        loc = mustache.loc;

    if (isLiteral$1(path)) {
        var _modifier = '{{' + printLiteral(path) + '}}';
        var tag = '<' + element.name + ' ... ' + _modifier + ' ...';
        throw new SyntaxError('In ' + tag + ', ' + _modifier + ' is not a valid modifier: "' + path.original + '" on line ' + (loc && loc.start.line) + '.', mustache.loc);
    }
    var modifier = b.elementModifier(path, params, hash, loc);
    element.modifiers.push(modifier);
}
function addInElementHash(cursor, hash, loc) {
    var hasNextSibling = false;
    hash.pairs.forEach(function (pair) {
        if (pair.key === 'guid') {
            throw new SyntaxError('Cannot pass `guid` from user space', loc);
        }
        if (pair.key === 'nextSibling') {
            hasNextSibling = true;
        }
    });
    var guid = b.literal('StringLiteral', cursor);
    var guidPair = b.pair('guid', guid);
    hash.pairs.unshift(guidPair);
    if (!hasNextSibling) {
        var nullLiteral = b.literal('NullLiteral', null);
        var nextSibling = b.pair('nextSibling', nullLiteral);
        hash.pairs.push(nextSibling);
    }
    return hash;
}
function appendDynamicAttributeValuePart(attribute, part) {
    attribute.isDynamic = true;
    attribute.parts.push(part);
}

var visitorKeys = {
    Program: ['body'],
    MustacheStatement: ['path', 'params', 'hash'],
    BlockStatement: ['path', 'params', 'hash', 'program', 'inverse'],
    ElementModifierStatement: ['path', 'params', 'hash'],
    PartialStatement: ['name', 'params', 'hash'],
    CommentStatement: [],
    MustacheCommentStatement: [],
    ElementNode: ['attributes', 'modifiers', 'children', 'comments'],
    AttrNode: ['value'],
    TextNode: [],
    ConcatStatement: ['parts'],
    SubExpression: ['path', 'params', 'hash'],
    PathExpression: [],
    StringLiteral: [],
    BooleanLiteral: [],
    NumberLiteral: [],
    NullLiteral: [],
    UndefinedLiteral: [],
    Hash: ['pairs'],
    HashPair: ['value']
};

var TraversalError = function () {
    TraversalError.prototype = Object.create(Error.prototype);
    TraversalError.prototype.constructor = TraversalError;
    function TraversalError(message, node, parent, key) {
        var error = Error.call(this, message);
        this.key = key;
        this.message = message;
        this.node = node;
        this.parent = parent;
        this.stack = error.stack;
    }
    return TraversalError;
}();
function cannotRemoveNode(node, parent, key) {
    return new TraversalError('Cannot remove a node unless it is part of an array', node, parent, key);
}
function cannotReplaceNode(node, parent, key) {
    return new TraversalError('Cannot replace a node with multiple nodes unless it is part of an array', node, parent, key);
}
function cannotReplaceOrRemoveInKeyHandlerYet(node, key) {
    return new TraversalError('Replacing and removing in key handlers is not yet supported.', node, null, key);
}

function visitNode(visitor, node) {
    var handler = visitor[node.type] || visitor.All || null;
    var result = void 0;
    if (handler && handler['enter']) {
        result = handler['enter'].call(null, node);
    }
    if (result !== undefined && result !== null) {
        if (JSON.stringify(node) === JSON.stringify(result)) {
            result = undefined;
        } else if (Array.isArray(result)) {
            return visitArray(visitor, result) || result;
        } else {
            return visitNode(visitor, result) || result;
        }
    }
    if (result === undefined) {
        var keys = visitorKeys[node.type];
        for (var i = 0; i < keys.length; i++) {
            visitKey(visitor, handler, node, keys[i]);
        }
        if (handler && handler['exit']) {
            result = handler['exit'].call(null, node);
        }
    }
    return result;
}
function visitKey(visitor, handler, node, key) {
    var value = node[key];
    if (!value) {
        return;
    }
    var keyHandler = handler && (handler.keys[key] || handler.keys.All);
    var result = void 0;
    if (keyHandler && keyHandler.enter) {
        result = keyHandler.enter.call(null, node, key);
        if (result !== undefined) {
            throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
        }
    }
    if (Array.isArray(value)) {
        visitArray(visitor, value);
    } else {
        var _result = visitNode(visitor, value);
        if (_result !== undefined) {
            assignKey(node, key, _result);
        }
    }
    if (keyHandler && keyHandler.exit) {
        result = keyHandler.exit.call(null, node, key);
        if (result !== undefined) {
            throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
        }
    }
}
function visitArray(visitor, array) {
    for (var i = 0; i < array.length; i++) {
        var result = visitNode(visitor, array[i]);
        if (result !== undefined) {
            i += spliceArray(array, i, result) - 1;
        }
    }
}
function assignKey(node, key, result) {
    if (result === null) {
        throw cannotRemoveNode(node[key], node, key);
    } else if (Array.isArray(result)) {
        if (result.length === 1) {
            node[key] = result[0];
        } else {
            if (result.length === 0) {
                throw cannotRemoveNode(node[key], node, key);
            } else {
                throw cannotReplaceNode(node[key], node, key);
            }
        }
    } else {
        node[key] = result;
    }
}
function spliceArray(array, index, result) {
    if (result === null) {
        array.splice(index, 1);
        return 0;
    } else if (Array.isArray(result)) {
        array.splice.apply(array, [index, 1].concat(result));
        return result.length;
    } else {
        array.splice(index, 1, result);
        return 1;
    }
}
function traverse(node, visitor) {
    visitNode(normalizeVisitor(visitor), node);
}
function normalizeVisitor(visitor) {
    var normalizedVisitor = {};
    for (var type in visitor) {
        var handler = visitor[type] || visitor.All;
        var normalizedKeys = {};
        if (typeof handler === 'object') {
            var keys = handler.keys;
            if (keys) {
                for (var key in keys) {
                    var keyHandler = keys[key];
                    if (typeof keyHandler === 'object') {
                        normalizedKeys[key] = {
                            enter: typeof keyHandler.enter === 'function' ? keyHandler.enter : null,
                            exit: typeof keyHandler.exit === 'function' ? keyHandler.exit : null
                        };
                    } else if (typeof keyHandler === 'function') {
                        normalizedKeys[key] = {
                            enter: keyHandler,
                            exit: null
                        };
                    }
                }
            }
            normalizedVisitor[type] = {
                enter: typeof handler.enter === 'function' ? handler.enter : null,
                exit: typeof handler.exit === 'function' ? handler.exit : null,
                keys: normalizedKeys
            };
        } else if (typeof handler === 'function') {
            normalizedVisitor[type] = {
                enter: handler,
                exit: null,
                keys: normalizedKeys
            };
        }
    }
    return normalizedVisitor;
}

function unreachable() {
    throw new Error('unreachable');
}
function build(ast) {
    if (!ast) {
        return '';
    }
    var output = [];
    switch (ast.type) {
        case 'Program':
            {
                var chainBlock = ast['chained'] && ast.body[0];
                if (chainBlock) {
                    chainBlock['chained'] = true;
                }
                var body = buildEach(ast.body).join('');
                output.push(body);
            }
            break;
        case 'ElementNode':
            output.push('<', ast.tag);
            if (ast.attributes.length) {
                output.push(' ', buildEach(ast.attributes).join(' '));
            }
            if (ast.modifiers.length) {
                output.push(' ', buildEach(ast.modifiers).join(' '));
            }
            if (ast.comments.length) {
                output.push(' ', buildEach(ast.comments).join(' '));
            }
            if (voidMap[ast.tag]) {
                if (ast.selfClosing) {
                    output.push(' /');
                }
                output.push('>');
            } else {
                output.push('>');
                output.push.apply(output, buildEach(ast.children));
                output.push('</', ast.tag, '>');
            }
            break;
        case 'AttrNode':
            output.push(ast.name, '=');
            var value = build(ast.value);
            if (ast.value.type === 'TextNode') {
                output.push('"', value, '"');
            } else {
                output.push(value);
            }
            break;
        case 'ConcatStatement':
            output.push('"');
            ast.parts.forEach(function (node) {
                if (node.type === 'StringLiteral') {
                    output.push(node.original);
                } else {
                    output.push(build(node));
                }
            });
            output.push('"');
            break;
        case 'TextNode':
            output.push(ast.chars);
            break;
        case 'MustacheStatement':
            {
                output.push(compactJoin(['{{', pathParams(ast), '}}']));
            }
            break;
        case 'MustacheCommentStatement':
            {
                output.push(compactJoin(['{{!--', ast.value, '--}}']));
            }
            break;
        case 'ElementModifierStatement':
            {
                output.push(compactJoin(['{{', pathParams(ast), '}}']));
            }
            break;
        case 'PathExpression':
            output.push(ast.original);
            break;
        case 'SubExpression':
            {
                output.push('(', pathParams(ast), ')');
            }
            break;
        case 'BooleanLiteral':
            output.push(ast.value ? 'true' : 'false');
            break;
        case 'BlockStatement':
            {
                var lines = [];
                if (ast['chained']) {
                    lines.push(['{{else ', pathParams(ast), '}}'].join(''));
                } else {
                    lines.push(openBlock(ast));
                }
                lines.push(build(ast.program));
                if (ast.inverse) {
                    if (!ast.inverse['chained']) {
                        lines.push('{{else}}');
                    }
                    lines.push(build(ast.inverse));
                }
                if (!ast['chained']) {
                    lines.push(closeBlock(ast));
                }
                output.push(lines.join(''));
            }
            break;
        case 'PartialStatement':
            {
                output.push(compactJoin(['{{>', pathParams(ast), '}}']));
            }
            break;
        case 'CommentStatement':
            {
                output.push(compactJoin(['<!--', ast.value, '-->']));
            }
            break;
        case 'StringLiteral':
            {
                output.push('"' + ast.value + '"');
            }
            break;
        case 'NumberLiteral':
            {
                output.push(String(ast.value));
            }
            break;
        case 'UndefinedLiteral':
            {
                output.push('undefined');
            }
            break;
        case 'NullLiteral':
            {
                output.push('null');
            }
            break;
        case 'Hash':
            {
                output.push(ast.pairs.map(function (pair) {
                    return build(pair);
                }).join(' '));
            }
            break;
        case 'HashPair':
            {
                output.push(ast.key + '=' + build(ast.value));
            }
            break;
    }
    return output.join('');
}
function compact(array) {
    var newArray = [];
    array.forEach(function (a) {
        if (typeof a !== 'undefined' && a !== null && a !== '') {
            newArray.push(a);
        }
    });
    return newArray;
}
function buildEach(asts) {
    return asts.map(build);
}
function pathParams(ast) {
    var path = void 0;
    switch (ast.type) {
        case 'MustacheStatement':
        case 'SubExpression':
        case 'ElementModifierStatement':
        case 'BlockStatement':
            if (isLiteral(ast.path)) {
                return String(ast.path.value);
            }
            path = build(ast.path);
            break;
        case 'PartialStatement':
            path = build(ast.name);
            break;
        default:
            return unreachable();
    }
    return compactJoin([path, buildEach(ast.params).join(' '), build(ast.hash)], ' ');
}
function compactJoin(array, delimiter) {
    return compact(array).join(delimiter || '');
}
function blockParams(block) {
    var params = block.program.blockParams;
    if (params.length) {
        return ' as |' + params.join(' ') + '|';
    }
    return null;
}
function openBlock(block) {
    return ['{{#', pathParams(block), blockParams(block), '}}'].join('');
}
function closeBlock(block) {
    return ['{{/', build(block.path), '}}'].join('');
}

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Walker = function () {
    function Walker(order) {
        _classCallCheck$3(this, Walker);

        this.order = order;
        this.stack = [];
    }

    Walker.prototype.visit = function visit(node, callback) {
        if (!node) {
            return;
        }
        this.stack.push(node);
        if (this.order === 'post') {
            this.children(node, callback);
            callback(node, this);
        } else {
            callback(node, this);
            this.children(node, callback);
        }
        this.stack.pop();
    };

    Walker.prototype.children = function children(node, callback) {
        var visitor = visitors[node.type];
        if (visitor) {
            visitor(this, node, callback);
        }
    };

    return Walker;
}();

var visitors = {
    Program: function Program(walker, node, callback) {
        for (var i = 0; i < node.body.length; i++) {
            walker.visit(node.body[i], callback);
        }
    },
    ElementNode: function ElementNode(walker, node, callback) {
        for (var i = 0; i < node.children.length; i++) {
            walker.visit(node.children[i], callback);
        }
    },
    BlockStatement: function BlockStatement(walker, node, callback) {
        walker.visit(node.program, callback);
        walker.visit(node.inverse || null, callback);
    }
};

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var voidMap = Object.create(null);
var voidTagNames = 'area base br col command embed hr img input keygen link meta param source track wbr';
voidTagNames.split(' ').forEach(function (tagName) {
    voidMap[tagName] = true;
});
var TokenizerEventHandlers = function (_HandlebarsNodeVisito) {
    _inherits(TokenizerEventHandlers, _HandlebarsNodeVisito);

    function TokenizerEventHandlers() {
        _classCallCheck(this, TokenizerEventHandlers);

        var _this = _possibleConstructorReturn(this, _HandlebarsNodeVisito.apply(this, arguments));

        _this.tagOpenLine = 0;
        _this.tagOpenColumn = 0;
        return _this;
    }

    TokenizerEventHandlers.prototype.reset = function reset() {
        this.currentNode = null;
    };
    // Comment


    TokenizerEventHandlers.prototype.beginComment = function beginComment() {
        this.currentNode = b.comment('');
        this.currentNode.loc = {
            source: null,
            start: b.pos(this.tagOpenLine, this.tagOpenColumn),
            end: null
        };
    };

    TokenizerEventHandlers.prototype.appendToCommentData = function appendToCommentData(char) {
        this.currentComment.value += char;
    };

    TokenizerEventHandlers.prototype.finishComment = function finishComment() {
        this.currentComment.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);
        appendChild(this.currentElement(), this.currentComment);
    };
    // Data


    TokenizerEventHandlers.prototype.beginData = function beginData() {
        this.currentNode = b.text();
        this.currentNode.loc = {
            source: null,
            start: b.pos(this.tokenizer.line, this.tokenizer.column),
            end: null
        };
    };

    TokenizerEventHandlers.prototype.appendToData = function appendToData(char) {
        this.currentData.chars += char;
    };

    TokenizerEventHandlers.prototype.finishData = function finishData() {
        this.currentData.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);
        appendChild(this.currentElement(), this.currentData);
    };
    // Tags - basic


    TokenizerEventHandlers.prototype.tagOpen = function tagOpen() {
        this.tagOpenLine = this.tokenizer.line;
        this.tagOpenColumn = this.tokenizer.column;
    };

    TokenizerEventHandlers.prototype.beginStartTag = function beginStartTag() {
        this.currentNode = {
            type: 'StartTag',
            name: '',
            attributes: [],
            modifiers: [],
            comments: [],
            selfClosing: false,
            loc: SYNTHETIC
        };
    };

    TokenizerEventHandlers.prototype.beginEndTag = function beginEndTag() {
        this.currentNode = {
            type: 'EndTag',
            name: '',
            attributes: [],
            modifiers: [],
            comments: [],
            selfClosing: false,
            loc: SYNTHETIC
        };
    };

    TokenizerEventHandlers.prototype.finishTag = function finishTag() {
        var _tokenizer = this.tokenizer,
            line = _tokenizer.line,
            column = _tokenizer.column;

        var tag = this.currentTag;
        tag.loc = b.loc(this.tagOpenLine, this.tagOpenColumn, line, column);
        if (tag.type === 'StartTag') {
            this.finishStartTag();
            if (voidMap[tag.name] || tag.selfClosing) {
                this.finishEndTag(true);
            }
        } else if (tag.type === 'EndTag') {
            this.finishEndTag(false);
        }
    };

    TokenizerEventHandlers.prototype.finishStartTag = function finishStartTag() {
        var _currentStartTag = this.currentStartTag,
            name = _currentStartTag.name,
            attributes = _currentStartTag.attributes,
            modifiers = _currentStartTag.modifiers,
            comments = _currentStartTag.comments,
            selfClosing = _currentStartTag.selfClosing;

        var loc = b.loc(this.tagOpenLine, this.tagOpenColumn);
        var element = b.element({ name: name, selfClosing: selfClosing }, attributes, modifiers, [], comments, loc);
        this.elementStack.push(element);
    };

    TokenizerEventHandlers.prototype.finishEndTag = function finishEndTag(isVoid) {
        var tag = this.currentTag;
        var element = this.elementStack.pop();
        var parent = this.currentElement();
        validateEndTag(tag, element, isVoid);
        element.loc.end.line = this.tokenizer.line;
        element.loc.end.column = this.tokenizer.column;
        parseElementBlockParams(element);
        appendChild(parent, element);
    };

    TokenizerEventHandlers.prototype.markTagAsSelfClosing = function markTagAsSelfClosing() {
        this.currentTag.selfClosing = true;
    };
    // Tags - name


    TokenizerEventHandlers.prototype.appendToTagName = function appendToTagName(char) {
        this.currentTag.name += char;
    };
    // Tags - attributes


    TokenizerEventHandlers.prototype.beginAttribute = function beginAttribute() {
        var tag = this.currentTag;
        if (tag.type === 'EndTag') {
            throw new SyntaxError('Invalid end tag: closing tag must not have attributes, ' + ('in `' + tag.name + '` (on line ' + this.tokenizer.line + ').'), tag.loc);
        }
        this.currentAttribute = {
            name: '',
            parts: [],
            isQuoted: false,
            isDynamic: false,
            start: b.pos(this.tokenizer.line, this.tokenizer.column),
            valueStartLine: 0,
            valueStartColumn: 0
        };
    };

    TokenizerEventHandlers.prototype.appendToAttributeName = function appendToAttributeName(char) {
        this.currentAttr.name += char;
    };

    TokenizerEventHandlers.prototype.beginAttributeValue = function beginAttributeValue(isQuoted) {
        this.currentAttr.isQuoted = isQuoted;
        this.currentAttr.valueStartLine = this.tokenizer.line;
        this.currentAttr.valueStartColumn = this.tokenizer.column;
    };

    TokenizerEventHandlers.prototype.appendToAttributeValue = function appendToAttributeValue(char) {
        var parts = this.currentAttr.parts;
        var lastPart = parts[parts.length - 1];
        if (lastPart && lastPart.type === 'TextNode') {
            lastPart.chars += char;
            // update end location for each added char
            lastPart.loc.end.line = this.tokenizer.line;
            lastPart.loc.end.column = this.tokenizer.column;
        } else {
            // initially assume the text node is a single char
            var loc = b.loc(this.tokenizer.line, this.tokenizer.column, this.tokenizer.line, this.tokenizer.column);
            // correct for `\n` as first char
            if (char === '\n') {
                loc.start.line -= 1;
                loc.start.column = lastPart ? lastPart.loc.end.column : this.currentAttr.valueStartColumn;
            }
            var text = b.text(char, loc);
            parts.push(text);
        }
    };

    TokenizerEventHandlers.prototype.finishAttributeValue = function finishAttributeValue() {
        var _currentAttr = this.currentAttr,
            name = _currentAttr.name,
            parts = _currentAttr.parts,
            isQuoted = _currentAttr.isQuoted,
            isDynamic = _currentAttr.isDynamic,
            valueStartLine = _currentAttr.valueStartLine,
            valueStartColumn = _currentAttr.valueStartColumn;

        var value = assembleAttributeValue(parts, isQuoted, isDynamic, this.tokenizer.line);
        value.loc = b.loc(valueStartLine, valueStartColumn, this.tokenizer.line, this.tokenizer.column);
        var loc = b.loc(this.currentAttr.start.line, this.currentAttr.start.column, this.tokenizer.line, this.tokenizer.column);
        var attribute = b.attr(name, value, loc);
        this.currentStartTag.attributes.push(attribute);
    };

    TokenizerEventHandlers.prototype.reportSyntaxError = function reportSyntaxError(message) {
        throw new SyntaxError('Syntax error at line ' + this.tokenizer.line + ' col ' + this.tokenizer.column + ': ' + message, b.loc(this.tokenizer.line, this.tokenizer.column));
    };

    return TokenizerEventHandlers;
}(HandlebarsNodeVisitors);
function assembleAttributeValue(parts, isQuoted, isDynamic, line) {
    if (isDynamic) {
        if (isQuoted) {
            return assembleConcatenatedValue(parts);
        } else {
            if (parts.length === 1 || parts.length === 2 && parts[1].type === 'TextNode' && parts[1].chars === '/') {
                return parts[0];
            } else {
                throw new SyntaxError('An unquoted attribute value must be a string or a mustache, ' + 'preceeded by whitespace or a \'=\' character, and ' + ('followed by whitespace, a \'>\' character, or \'/>\' (on line ' + line + ')'), b.loc(line, 0));
            }
        }
    } else {
        return parts.length > 0 ? parts[0] : b.text('');
    }
}
function assembleConcatenatedValue(parts) {
    for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {
            throw new SyntaxError('Unsupported node in quoted attribute value: ' + part['type'], part.loc);
        }
    }
    return b.concat(parts);
}
function validateEndTag(tag, element, selfClosing) {
    var error = void 0;
    if (voidMap[tag.name] && !selfClosing) {
        // EngTag is also called by StartTag for void and self-closing tags (i.e.
        // <input> or <br />, so we need to check for that here. Otherwise, we would
        // throw an error for those cases.
        error = 'Invalid end tag ' + formatEndTagInfo(tag) + ' (void elements cannot have end tags).';
    } else if (element.tag === undefined) {
        error = 'Closing tag ' + formatEndTagInfo(tag) + ' without an open tag.';
    } else if (element.tag !== tag.name) {
        error = 'Closing tag ' + formatEndTagInfo(tag) + ' did not match last open tag `' + element.tag + '` (on line ' + element.loc.start.line + ').';
    }
    if (error) {
        throw new SyntaxError(error, element.loc);
    }
}
function formatEndTagInfo(tag) {
    return '`' + tag.name + '` (on line ' + tag.loc.end.line + ')';
}
var syntax = {
    parse: preprocess,
    builders: b,
    print: build,
    traverse: traverse,
    Walker: Walker
};
function preprocess(html, options) {
    var ast = typeof html === 'object' ? html : handlebars.parse(html);
    var program = new TokenizerEventHandlers(html).acceptNode(ast);
    if (options && options.plugins && options.plugins.ast) {
        for (var i = 0, l = options.plugins.ast.length; i < l; i++) {
            var transform = options.plugins.ast[i];
            var env = util.assign({}, options, { syntax: syntax }, { plugins: undefined });
            var pluginResult = transform(env);
            traverse(program, pluginResult.visitor);
        }
    }
    return program;
}

// used by ember-compiler
// AST

exports.AST = nodes;
exports.preprocess = preprocess;
exports.builders = b;
exports.TraversalError = TraversalError;
exports.cannotRemoveNode = cannotRemoveNode;
exports.cannotReplaceNode = cannotReplaceNode;
exports.cannotReplaceOrRemoveInKeyHandlerYet = cannotReplaceOrRemoveInKeyHandlerYet;
exports.traverse = traverse;
exports.Walker = Walker;
exports.print = build;
exports.SyntaxError = SyntaxError;
exports.isLiteral = isLiteral$1;
exports.printLiteral = printLiteral;

Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1zeW50YXguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdHlwZXMvbm9kZXMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL2J1aWxkZXJzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9lcnJvcnMvc3ludGF4LWVycm9yLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi91dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9wYXJzZXIvaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi90eXBlcy92aXNpdG9yLWtleXMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3RyYXZlcnNhbC9lcnJvcnMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3RyYXZlcnNhbC90cmF2ZXJzZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvZ2VuZXJhdGlvbi9wcmludC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdHJhdmVyc2FsL3dhbGtlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL3Rva2VuaXplci1ldmVudC1oYW5kbGVycy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBPcHRpb248VD4gPSBUIHwgbnVsbDtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlTm9kZSB7XG4gIC8vIEV2ZXJ5IGxlYWYgaW50ZXJmYWNlIHRoYXQgZXh0ZW5kcyBCYXNlTm9kZSBtdXN0IHNwZWNpZnkgYSB0eXBlIHByb3BlcnR5LlxuICAvLyBUaGUgdHlwZSBwcm9wZXJ0eSBzaG91bGQgYmUgYSBzdHJpbmcgbGl0ZXJhbC4gRm9yIGV4YW1wbGUsIElkZW50aWZpZXJcbiAgLy8gaGFzOiBgdHlwZTogXCJJZGVudGlmaWVyXCJgXG4gIHR5cGU6IE5vZGVUeXBlO1xuICBsb2M6IFNvdXJjZUxvY2F0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNvdXJjZUxvY2F0aW9uIHtcbiAgc291cmNlPzogT3B0aW9uPHN0cmluZz47XG4gIHN0YXJ0OiBQb3NpdGlvbjtcbiAgZW5kOiBQb3NpdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb3NpdGlvbiB7XG4gIC8qKiA+PSAxICovXG4gIGxpbmU6IG51bWJlcjtcbiAgLyoqID49IDAgKi9cbiAgY29sdW1uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ1Byb2dyYW0nO1xuICBib2R5OiBTdGF0ZW1lbnRbXTtcbiAgYmxvY2tQYXJhbXM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgdHlwZSBTdGF0ZW1lbnQgPVxuICB8IE11c3RhY2hlU3RhdGVtZW50XG4gIHwgQmxvY2tTdGF0ZW1lbnRcbiAgfCBQYXJ0aWFsU3RhdGVtZW50XG4gIHwgTXVzdGFjaGVDb21tZW50U3RhdGVtZW50XG4gIHwgQ29tbWVudFN0YXRlbWVudFxuICB8IFRleHROb2RlXG4gIHwgRWxlbWVudE5vZGU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbCBleHRlbmRzIEJhc2VOb2RlIHtcbiAgbmFtZT86IFBhdGhFeHByZXNzaW9uIHwgU3ViRXhwcmVzc2lvbjtcbiAgcGF0aDogUGF0aEV4cHJlc3Npb247XG4gIHBhcmFtczogRXhwcmVzc2lvbltdO1xuICBoYXNoOiBIYXNoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE11c3RhY2hlU3RhdGVtZW50IGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnTXVzdGFjaGVTdGF0ZW1lbnQnO1xuICBwYXRoOiBQYXRoRXhwcmVzc2lvbiB8IExpdGVyYWw7XG4gIHBhcmFtczogRXhwcmVzc2lvbltdO1xuICBoYXNoOiBIYXNoO1xuICBlc2NhcGVkOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NrU3RhdGVtZW50IGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnQmxvY2tTdGF0ZW1lbnQnO1xuICBwYXRoOiBQYXRoRXhwcmVzc2lvbjtcbiAgcGFyYW1zOiBFeHByZXNzaW9uW107XG4gIGhhc2g6IEhhc2g7XG4gIHByb2dyYW06IFByb2dyYW07XG4gIGludmVyc2U/OiBPcHRpb248UHJvZ3JhbT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50IGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50JztcbiAgcGF0aDogUGF0aEV4cHJlc3Npb247XG4gIHBhcmFtczogRXhwcmVzc2lvbltdO1xuICBoYXNoOiBIYXNoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRpYWxTdGF0ZW1lbnQgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdQYXJ0aWFsU3RhdGVtZW50JztcbiAgbmFtZTogUGF0aEV4cHJlc3Npb24gfCBTdWJFeHByZXNzaW9uO1xuICBwYXJhbXM6IEV4cHJlc3Npb25bXTtcbiAgaGFzaDogSGFzaDtcbiAgaW5kZW50OiBzdHJpbmc7XG4gIHN0cmlwOiBTdHJpcEZsYWdzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDYWxsKG5vZGU6IGFueSk6IG5vZGUgaXMgQ2FsbCB7XG4gIHJldHVybiAoXG4gICAgbm9kZS50eXBlID09PSAnU3ViRXhwcmVzc2lvbicgfHxcbiAgICAobm9kZS50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnICYmIG5vZGUucGF0aC50eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKVxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbW1lbnRTdGF0ZW1lbnQgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdDb21tZW50U3RhdGVtZW50JztcbiAgdmFsdWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVsZW1lbnROb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnRWxlbWVudE5vZGUnO1xuICB0YWc6IHN0cmluZztcbiAgc2VsZkNsb3Npbmc6IGJvb2xlYW47XG4gIGF0dHJpYnV0ZXM6IEF0dHJOb2RlW107XG4gIGJsb2NrUGFyYW1zOiBzdHJpbmdbXTtcbiAgbW9kaWZpZXJzOiBFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnRbXTtcbiAgY29tbWVudHM6IE11c3RhY2hlQ29tbWVudFN0YXRlbWVudFtdO1xuICBjaGlsZHJlbjogU3RhdGVtZW50W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0ck5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdBdHRyTm9kZSc7XG4gIG5hbWU6IHN0cmluZztcbiAgdmFsdWU6IFRleHROb2RlIHwgTXVzdGFjaGVTdGF0ZW1lbnQgfCBDb25jYXRTdGF0ZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dE5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdUZXh0Tm9kZSc7XG4gIGNoYXJzOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uY2F0U3RhdGVtZW50IGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnQ29uY2F0U3RhdGVtZW50JztcbiAgcGFydHM6IChUZXh0Tm9kZSB8IE11c3RhY2hlU3RhdGVtZW50KVtdO1xufVxuXG5leHBvcnQgdHlwZSBFeHByZXNzaW9uID0gU3ViRXhwcmVzc2lvbiB8IFBhdGhFeHByZXNzaW9uIHwgTGl0ZXJhbDtcblxuZXhwb3J0IGludGVyZmFjZSBTdWJFeHByZXNzaW9uIGV4dGVuZHMgQ2FsbCB7XG4gIHR5cGU6ICdTdWJFeHByZXNzaW9uJztcbiAgcGF0aDogUGF0aEV4cHJlc3Npb247XG4gIHBhcmFtczogRXhwcmVzc2lvbltdO1xuICBoYXNoOiBIYXNoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhFeHByZXNzaW9uIGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnUGF0aEV4cHJlc3Npb24nO1xuICBkYXRhOiBib29sZWFuO1xuICBvcmlnaW5hbDogc3RyaW5nO1xuICB0aGlzOiBib29sZWFuO1xuICBwYXJ0czogc3RyaW5nW107XG59XG5cbmV4cG9ydCB0eXBlIExpdGVyYWwgPVxuICB8IFN0cmluZ0xpdGVyYWxcbiAgfCBCb29sZWFuTGl0ZXJhbFxuICB8IE51bWJlckxpdGVyYWxcbiAgfCBVbmRlZmluZWRMaXRlcmFsXG4gIHwgTnVsbExpdGVyYWw7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyaW5nTGl0ZXJhbCBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ1N0cmluZ0xpdGVyYWwnO1xuICB2YWx1ZTogc3RyaW5nO1xuICBvcmlnaW5hbDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJvb2xlYW5MaXRlcmFsIGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnQm9vbGVhbkxpdGVyYWwnO1xuICB2YWx1ZTogYm9vbGVhbjtcbiAgb3JpZ2luYWw6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTnVtYmVyTGl0ZXJhbCBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ051bWJlckxpdGVyYWwnO1xuICB2YWx1ZTogbnVtYmVyO1xuICBvcmlnaW5hbDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVuZGVmaW5lZExpdGVyYWwgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdVbmRlZmluZWRMaXRlcmFsJztcbiAgdmFsdWU6IHVuZGVmaW5lZDtcbiAgb3JpZ2luYWw6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOdWxsTGl0ZXJhbCBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ051bGxMaXRlcmFsJztcbiAgdmFsdWU6IG51bGw7XG4gIG9yaWdpbmFsOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMaXRlcmFsKGlucHV0OiBOb2RlIHwgc3RyaW5nKTogaW5wdXQgaXMgTGl0ZXJhbCB7XG4gIHJldHVybiAhISh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0LnR5cGUubWF0Y2goL0xpdGVyYWwkLykpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhc2ggZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdIYXNoJztcbiAgcGFpcnM6IEhhc2hQYWlyW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFzaFBhaXIgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdIYXNoUGFpcic7XG4gIGtleTogc3RyaW5nO1xuICB2YWx1ZTogRXhwcmVzc2lvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdHJpcEZsYWdzIHtcbiAgb3BlbjogYm9vbGVhbjtcbiAgY2xvc2U6IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIE5vZGVUeXBlID0ga2V5b2YgTm9kZXM7XG5cbmV4cG9ydCB0eXBlIE5vZGUgPSBOb2Rlc1tOb2RlVHlwZV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9kZXMge1xuICBQcm9ncmFtOiBQcm9ncmFtO1xuICBFbGVtZW50Tm9kZTogRWxlbWVudE5vZGU7XG4gIEF0dHJOb2RlOiBBdHRyTm9kZTtcbiAgVGV4dE5vZGU6IFRleHROb2RlO1xuICBNdXN0YWNoZVN0YXRlbWVudDogTXVzdGFjaGVTdGF0ZW1lbnQ7XG4gIEJsb2NrU3RhdGVtZW50OiBCbG9ja1N0YXRlbWVudDtcbiAgUGFydGlhbFN0YXRlbWVudDogUGFydGlhbFN0YXRlbWVudDtcbiAgQ29uY2F0U3RhdGVtZW50OiBDb25jYXRTdGF0ZW1lbnQ7XG4gIE11c3RhY2hlQ29tbWVudFN0YXRlbWVudDogTXVzdGFjaGVDb21tZW50U3RhdGVtZW50O1xuICBFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQ6IEVsZW1lbnRNb2RpZmllclN0YXRlbWVudDtcbiAgQ29tbWVudFN0YXRlbWVudDogQ29tbWVudFN0YXRlbWVudDtcbiAgUGF0aEV4cHJlc3Npb246IFBhdGhFeHByZXNzaW9uO1xuICBTdWJFeHByZXNzaW9uOiBTdWJFeHByZXNzaW9uO1xuICBIYXNoOiBIYXNoO1xuICBIYXNoUGFpcjogSGFzaFBhaXI7XG4gIFN0cmluZ0xpdGVyYWw6IFN0cmluZ0xpdGVyYWw7XG4gIEJvb2xlYW5MaXRlcmFsOiBCb29sZWFuTGl0ZXJhbDtcbiAgTnVtYmVyTGl0ZXJhbDogTnVtYmVyTGl0ZXJhbDtcbiAgVW5kZWZpbmVkTGl0ZXJhbDogVW5kZWZpbmVkTGl0ZXJhbDtcbiAgTnVsbExpdGVyYWw6IE51bGxMaXRlcmFsO1xufVxuIiwiaW1wb3J0ICogYXMgQVNUIGZyb20gJy4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbi8vIFN0YXRlbWVudHNcblxuZXhwb3J0IHR5cGUgQnVpbGRlclBhdGggPSBzdHJpbmcgfCBBU1QuUGF0aEV4cHJlc3Npb247XG5leHBvcnQgdHlwZSBUYWdEZXNjcmlwdG9yID0gc3RyaW5nIHwgeyBuYW1lOiBzdHJpbmc7IHNlbGZDbG9zaW5nOiBib29sZWFuIH07XG5cbmZ1bmN0aW9uIGJ1aWxkTXVzdGFjaGUoXG4gIHBhdGg6IEJ1aWxkZXJQYXRoIHwgQVNULkxpdGVyYWwsXG4gIHBhcmFtcz86IEFTVC5FeHByZXNzaW9uW10sXG4gIGhhc2g/OiBBU1QuSGFzaCxcbiAgcmF3PzogYm9vbGVhbixcbiAgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uXG4pOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQge1xuICBpZiAoIUFTVC5pc0xpdGVyYWwocGF0aCkpIHtcbiAgICBwYXRoID0gYnVpbGRQYXRoKHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTXVzdGFjaGVTdGF0ZW1lbnQnLFxuICAgIHBhdGgsXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIGVzY2FwZWQ6ICFyYXcsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQmxvY2soXG4gIHBhdGg6IEJ1aWxkZXJQYXRoLFxuICBwYXJhbXM6IE9wdGlvbjxBU1QuRXhwcmVzc2lvbltdPixcbiAgaGFzaDogT3B0aW9uPEFTVC5IYXNoPixcbiAgcHJvZ3JhbTogQVNULlByb2dyYW0sXG4gIGludmVyc2U/OiBPcHRpb248QVNULlByb2dyYW0+LFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb25cbik6IEFTVC5CbG9ja1N0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICBwYXRoOiBidWlsZFBhdGgocGF0aCksXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIHByb2dyYW06IHByb2dyYW0gfHwgbnVsbCxcbiAgICBpbnZlcnNlOiBpbnZlcnNlIHx8IG51bGwsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRWxlbWVudE1vZGlmaWVyKFxuICBwYXRoOiBCdWlsZGVyUGF0aCxcbiAgcGFyYW1zPzogQVNULkV4cHJlc3Npb25bXSxcbiAgaGFzaD86IEFTVC5IYXNoLFxuICBsb2M/OiBPcHRpb248QVNULlNvdXJjZUxvY2F0aW9uPlxuKTogQVNULkVsZW1lbnRNb2RpZmllclN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0VsZW1lbnRNb2RpZmllclN0YXRlbWVudCcsXG4gICAgcGF0aDogYnVpbGRQYXRoKHBhdGgpLFxuICAgIHBhcmFtczogcGFyYW1zIHx8IFtdLFxuICAgIGhhc2g6IGhhc2ggfHwgYnVpbGRIYXNoKFtdKSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYXJ0aWFsKFxuICBuYW1lOiBBU1QuUGF0aEV4cHJlc3Npb24sXG4gIHBhcmFtcz86IEFTVC5FeHByZXNzaW9uW10sXG4gIGhhc2g/OiBBU1QuSGFzaCxcbiAgaW5kZW50Pzogc3RyaW5nLFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb25cbik6IEFTVC5QYXJ0aWFsU3RhdGVtZW50IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnUGFydGlhbFN0YXRlbWVudCcsXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXSxcbiAgICBoYXNoOiBoYXNoIHx8IGJ1aWxkSGFzaChbXSksXG4gICAgaW5kZW50OiBpbmRlbnQgfHwgJycsXG4gICAgc3RyaXA6IHsgb3BlbjogZmFsc2UsIGNsb3NlOiBmYWxzZSB9LFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZENvbW1lbnQodmFsdWU6IHN0cmluZywgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uKTogQVNULkNvbW1lbnRTdGF0ZW1lbnQge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdDb21tZW50U3RhdGVtZW50JyxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTXVzdGFjaGVDb21tZW50KFxuICB2YWx1ZTogc3RyaW5nLFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb25cbik6IEFTVC5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRDb25jYXQoXG4gIHBhcnRzOiAoQVNULlRleHROb2RlIHwgQVNULk11c3RhY2hlU3RhdGVtZW50KVtdLFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb25cbik6IEFTVC5Db25jYXRTdGF0ZW1lbnQge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdDb25jYXRTdGF0ZW1lbnQnLFxuICAgIHBhcnRzOiBwYXJ0cyB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuLy8gTm9kZXNcblxuZnVuY3Rpb24gYnVpbGRFbGVtZW50KFxuICB0YWc6IFRhZ0Rlc2NyaXB0b3IsXG4gIGF0dHJpYnV0ZXM/OiBBU1QuQXR0ck5vZGVbXSxcbiAgbW9kaWZpZXJzPzogQVNULkVsZW1lbnRNb2RpZmllclN0YXRlbWVudFtdLFxuICBjaGlsZHJlbj86IEFTVC5TdGF0ZW1lbnRbXSxcbiAgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uXG4pOiBBU1QuRWxlbWVudE5vZGU7XG5mdW5jdGlvbiBidWlsZEVsZW1lbnQoXG4gIHRhZzogVGFnRGVzY3JpcHRvcixcbiAgYXR0cmlidXRlcz86IEFTVC5BdHRyTm9kZVtdLFxuICBtb2RpZmllcnM/OiBBU1QuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50W10sXG4gIGNoaWxkcmVuPzogQVNULlN0YXRlbWVudFtdLFxuICBjb21tZW50cz86IEFTVC5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnRbXSxcbiAgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uXG4pOiBBU1QuRWxlbWVudE5vZGU7XG5cbmZ1bmN0aW9uIGJ1aWxkRWxlbWVudChcbiAgdGFnOiBUYWdEZXNjcmlwdG9yLFxuICBhdHRyaWJ1dGVzPzogQVNULkF0dHJOb2RlW10sXG4gIG1vZGlmaWVycz86IEFTVC5FbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnRbXSxcbiAgY2hpbGRyZW4/OiBBU1QuU3RhdGVtZW50W10sXG4gIGNvbW1lbnRzPzogQVNULk11c3RhY2hlQ29tbWVudFN0YXRlbWVudFtdIHwgQVNULlNvdXJjZUxvY2F0aW9uLFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb25cbik6IEFTVC5FbGVtZW50Tm9kZSB7XG4gIC8vIHRoaXMgaXMgdXNlZCBmb3IgYmFja3dhcmRzIGNvbXBhdCBwcmlvciB0byBgY29tbWVudHNgIGJlaW5nIGFkZGVkIHRvIHRoZSBBU1RcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbW1lbnRzKSkge1xuICAgIGxvYyA9IGNvbW1lbnRzO1xuICAgIGNvbW1lbnRzID0gW107XG4gIH1cblxuICAvLyB0aGlzIGlzIHVzZWQgZm9yIGJhY2t3YXJkcyBjb21wYXQsIHByaW9yIHRvIGBzZWxmQ2xvc2luZ2AgYmVpbmcgcGFydCBvZiB0aGUgRWxlbWVudE5vZGUgQVNUXG4gIGxldCBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ29iamVjdCcpIHtcbiAgICBzZWxmQ2xvc2luZyA9IHRhZy5zZWxmQ2xvc2luZztcbiAgICB0YWcgPSB0YWcubmFtZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0VsZW1lbnROb2RlJyxcbiAgICB0YWc6IHRhZyB8fCAnJyxcbiAgICBzZWxmQ2xvc2luZzogc2VsZkNsb3NpbmcsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyB8fCBbXSxcbiAgICBibG9ja1BhcmFtczogW10sXG4gICAgbW9kaWZpZXJzOiBtb2RpZmllcnMgfHwgW10sXG4gICAgY29tbWVudHM6IGNvbW1lbnRzIHx8IFtdLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbiB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBdHRyKFxuICBuYW1lOiBzdHJpbmcsXG4gIHZhbHVlOiBBU1QuQXR0ck5vZGVbJ3ZhbHVlJ10sXG4gIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvblxuKTogQVNULkF0dHJOb2RlIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQXR0ck5vZGUnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFRleHQoY2hhcnM/OiBzdHJpbmcsIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvbik6IEFTVC5UZXh0Tm9kZSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RleHROb2RlJyxcbiAgICBjaGFyczogY2hhcnMgfHwgJycsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbi8vIEV4cHJlc3Npb25zXG5cbmZ1bmN0aW9uIGJ1aWxkU2V4cHIoXG4gIHBhdGg6IEJ1aWxkZXJQYXRoLFxuICBwYXJhbXM/OiBBU1QuRXhwcmVzc2lvbltdLFxuICBoYXNoPzogQVNULkhhc2gsXG4gIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvblxuKTogQVNULlN1YkV4cHJlc3Npb24ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdTdWJFeHByZXNzaW9uJyxcbiAgICBwYXRoOiBidWlsZFBhdGgocGF0aCksXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFBhdGgob3JpZ2luYWw6IEJ1aWxkZXJQYXRoLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuUGF0aEV4cHJlc3Npb24ge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnc3RyaW5nJykgcmV0dXJuIG9yaWdpbmFsO1xuXG4gIGxldCBwYXJ0cyA9IG9yaWdpbmFsLnNwbGl0KCcuJyk7XG4gIGxldCB0aGlzSGVhZCA9IGZhbHNlO1xuXG4gIGlmIChwYXJ0c1swXSA9PT0gJ3RoaXMnKSB7XG4gICAgdGhpc0hlYWQgPSB0cnVlO1xuICAgIHBhcnRzID0gcGFydHMuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXG4gICAgb3JpZ2luYWwsXG4gICAgdGhpczogdGhpc0hlYWQsXG4gICAgcGFydHMsXG4gICAgZGF0YTogZmFsc2UsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGl0ZXJhbDxUIGV4dGVuZHMgQVNULkxpdGVyYWw+KFxuICB0eXBlOiBUWyd0eXBlJ10sXG4gIHZhbHVlOiBUWyd2YWx1ZSddLFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb25cbik6IEFTVC5MaXRlcmFsIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHZhbHVlLFxuICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfSBhcyBBU1QuTGl0ZXJhbDtcbn1cblxuLy8gTWlzY2VsbGFuZW91c1xuXG5mdW5jdGlvbiBidWlsZEhhc2gocGFpcnM/OiBBU1QuSGFzaFBhaXJbXSwgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uKTogQVNULkhhc2gge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdIYXNoJyxcbiAgICBwYWlyczogcGFpcnMgfHwgW10sXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGFpcihrZXk6IHN0cmluZywgdmFsdWU6IEFTVC5FeHByZXNzaW9uLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuSGFzaFBhaXIge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdIYXNoUGFpcicsXG4gICAga2V5OiBrZXksXG4gICAgdmFsdWUsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUHJvZ3JhbShcbiAgYm9keT86IEFTVC5TdGF0ZW1lbnRbXSxcbiAgYmxvY2tQYXJhbXM/OiBzdHJpbmdbXSxcbiAgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uXG4pOiBBU1QuUHJvZ3JhbSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1Byb2dyYW0nLFxuICAgIGJvZHk6IGJvZHkgfHwgW10sXG4gICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zIHx8IFtdLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFNvdXJjZShzb3VyY2U/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHNvdXJjZSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBidWlsZFBvc2l0aW9uKGxpbmU6IG51bWJlciwgY29sdW1uOiBudW1iZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBsaW5lLFxuICAgIGNvbHVtbixcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNZTlRIRVRJQzogQVNULlNvdXJjZUxvY2F0aW9uID0ge1xuICBzb3VyY2U6ICcoc3ludGhldGljKScsXG4gIHN0YXJ0OiB7IGxpbmU6IDEsIGNvbHVtbjogMCB9LFxuICBlbmQ6IHsgbGluZTogMSwgY29sdW1uOiAwIH0sXG59O1xuXG5mdW5jdGlvbiBidWlsZExvYyhsb2M6IE9wdGlvbjxBU1QuU291cmNlTG9jYXRpb24+KTogQVNULlNvdXJjZUxvY2F0aW9uO1xuZnVuY3Rpb24gYnVpbGRMb2MoXG4gIHN0YXJ0TGluZTogbnVtYmVyLFxuICBzdGFydENvbHVtbjogbnVtYmVyLFxuICBlbmRMaW5lPzogbnVtYmVyLFxuICBlbmRDb2x1bW4/OiBudW1iZXIsXG4gIHNvdXJjZT86IHN0cmluZ1xuKTogQVNULlNvdXJjZUxvY2F0aW9uO1xuXG5mdW5jdGlvbiBidWlsZExvYyguLi5hcmdzOiBhbnlbXSk6IEFTVC5Tb3VyY2VMb2NhdGlvbiB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIGxldCBsb2MgPSBhcmdzWzBdO1xuXG4gICAgaWYgKGxvYyAmJiB0eXBlb2YgbG9jID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBidWlsZFNvdXJjZShsb2Muc291cmNlKSxcbiAgICAgICAgc3RhcnQ6IGJ1aWxkUG9zaXRpb24obG9jLnN0YXJ0LmxpbmUsIGxvYy5zdGFydC5jb2x1bW4pLFxuICAgICAgICBlbmQ6IGJ1aWxkUG9zaXRpb24obG9jLmVuZC5saW5lLCBsb2MuZW5kLmNvbHVtbiksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gU1lOVEhFVElDO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgW3N0YXJ0TGluZSwgc3RhcnRDb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbiwgc291cmNlXSA9IGFyZ3M7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogYnVpbGRTb3VyY2Uoc291cmNlKSxcbiAgICAgIHN0YXJ0OiBidWlsZFBvc2l0aW9uKHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4pLFxuICAgICAgZW5kOiBidWlsZFBvc2l0aW9uKGVuZExpbmUsIGVuZENvbHVtbiksXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG11c3RhY2hlOiBidWlsZE11c3RhY2hlLFxuICBibG9jazogYnVpbGRCbG9jayxcbiAgcGFydGlhbDogYnVpbGRQYXJ0aWFsLFxuICBjb21tZW50OiBidWlsZENvbW1lbnQsXG4gIG11c3RhY2hlQ29tbWVudDogYnVpbGRNdXN0YWNoZUNvbW1lbnQsXG4gIGVsZW1lbnQ6IGJ1aWxkRWxlbWVudCxcbiAgZWxlbWVudE1vZGlmaWVyOiBidWlsZEVsZW1lbnRNb2RpZmllcixcbiAgYXR0cjogYnVpbGRBdHRyLFxuICB0ZXh0OiBidWlsZFRleHQsXG4gIHNleHByOiBidWlsZFNleHByLFxuICBwYXRoOiBidWlsZFBhdGgsXG4gIGNvbmNhdDogYnVpbGRDb25jYXQsXG4gIGhhc2g6IGJ1aWxkSGFzaCxcbiAgcGFpcjogYnVpbGRQYWlyLFxuICBsaXRlcmFsOiBidWlsZExpdGVyYWwsXG4gIHByb2dyYW06IGJ1aWxkUHJvZ3JhbSxcbiAgbG9jOiBidWlsZExvYyxcbiAgcG9zOiBidWlsZFBvc2l0aW9uLFxuXG4gIHN0cmluZzogbGl0ZXJhbCgnU3RyaW5nTGl0ZXJhbCcpLFxuICBib29sZWFuOiBsaXRlcmFsKCdCb29sZWFuTGl0ZXJhbCcpLFxuICBudW1iZXI6IGxpdGVyYWwoJ051bWJlckxpdGVyYWwnKSxcbiAgdW5kZWZpbmVkKCkge1xuICAgIHJldHVybiBidWlsZExpdGVyYWwoJ1VuZGVmaW5lZExpdGVyYWwnLCB1bmRlZmluZWQpO1xuICB9LFxuICBudWxsKCkge1xuICAgIHJldHVybiBidWlsZExpdGVyYWwoJ051bGxMaXRlcmFsJywgbnVsbCk7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBsaXRlcmFsPFQgZXh0ZW5kcyBBU1QuTGl0ZXJhbD4odHlwZTogVFsndHlwZSddKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZTogVFsndmFsdWUnXSkge1xuICAgIHJldHVybiBidWlsZExpdGVyYWwodHlwZSwgdmFsdWUpO1xuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgQVNUIGZyb20gJy4uL3R5cGVzL25vZGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgbG9jYXRpb246IEFTVC5Tb3VyY2VMb2NhdGlvbjtcbiAgY29uc3RydWN0b3I6IFN5bnRheEVycm9yQ29uc3RydWN0b3I7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3ludGF4RXJyb3JDb25zdHJ1Y3RvciB7XG4gIG5ldyAobWVzc2FnZTogc3RyaW5nLCBsb2NhdGlvbjogQVNULlNvdXJjZUxvY2F0aW9uKTogU3ludGF4RXJyb3I7XG4gIHJlYWRvbmx5IHByb3RvdHlwZTogU3ludGF4RXJyb3I7XG59XG5cbi8qKlxuICogU3ViY2xhc3Mgb2YgYEVycm9yYCB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIGFib3V0IGxvY2F0aW9uIG9mIGluY29ycmVjdCBtYXJrdXAuXG4gKi9cbmNvbnN0IFN5bnRheEVycm9yOiBTeW50YXhFcnJvckNvbnN0cnVjdG9yID0gKGZ1bmN0aW9uKCkge1xuICBTeW50YXhFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIFN5bnRheEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bnRheEVycm9yO1xuXG4gIGZ1bmN0aW9uIFN5bnRheEVycm9yKHRoaXM6IFN5bnRheEVycm9yLCBtZXNzYWdlOiBzdHJpbmcsIGxvY2F0aW9uOiBBU1QuU291cmNlTG9jYXRpb24pIHtcbiAgICBsZXQgZXJyb3IgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICB9XG5cbiAgcmV0dXJuIFN5bnRheEVycm9yIGFzIGFueTtcbn0pKCk7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bnRheEVycm9yO1xuIiwiaW1wb3J0ICogYXMgQVNUIGZyb20gJy4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgU3ludGF4RXJyb3IgZnJvbSAnLi9lcnJvcnMvc3ludGF4LWVycm9yJztcblxuLy8gUmVnZXggdG8gdmFsaWRhdGUgdGhlIGlkZW50aWZpZXIgZm9yIGJsb2NrIHBhcmFtZXRlcnMuXG4vLyBCYXNlZCBvbiB0aGUgSUQgdmFsaWRhdGlvbiByZWdleCBpbiBIYW5kbGViYXJzLlxuXG5sZXQgSURfSU5WRVJTRV9QQVRURVJOID0gL1shXCIjJS0sXFwuXFwvOy0+QFxcWy1cXF5gXFx7LX5dLztcblxuLy8gQ2hlY2tzIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlcyB0byBzZWUgaWYgaXQgdXNlcyBibG9jayBwYXJhbXMuXG4vLyBJZiBpdCBkb2VzLCByZWdpc3RlcnMgdGhlIGJsb2NrIHBhcmFtcyB3aXRoIHRoZSBwcm9ncmFtIGFuZFxuLy8gcmVtb3ZlcyB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzIGZyb20gdGhlIGVsZW1lbnQuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVsZW1lbnRCbG9ja1BhcmFtcyhlbGVtZW50OiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgbGV0IHBhcmFtcyA9IHBhcnNlQmxvY2tQYXJhbXMoZWxlbWVudCk7XG4gIGlmIChwYXJhbXMpIGVsZW1lbnQuYmxvY2tQYXJhbXMgPSBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQmxvY2tQYXJhbXMoZWxlbWVudDogQVNULkVsZW1lbnROb2RlKTogT3B0aW9uPHN0cmluZ1tdPiB7XG4gIGxldCBsID0gZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgbGV0IGF0dHJOYW1lcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgYXR0ck5hbWVzLnB1c2goZWxlbWVudC5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICB9XG5cbiAgbGV0IGFzSW5kZXggPSBhdHRyTmFtZXMuaW5kZXhPZignYXMnKTtcblxuICBpZiAoYXNJbmRleCAhPT0gLTEgJiYgbCA+IGFzSW5kZXggJiYgYXR0ck5hbWVzW2FzSW5kZXggKyAxXS5jaGFyQXQoMCkgPT09ICd8Jykge1xuICAgIC8vIFNvbWUgYmFzaWMgdmFsaWRhdGlvbiwgc2luY2Ugd2UncmUgZG9pbmcgdGhlIHBhcnNpbmcgb3Vyc2VsdmVzXG4gICAgbGV0IHBhcmFtc1N0cmluZyA9IGF0dHJOYW1lcy5zbGljZShhc0luZGV4KS5qb2luKCcgJyk7XG4gICAgaWYgKFxuICAgICAgcGFyYW1zU3RyaW5nLmNoYXJBdChwYXJhbXNTdHJpbmcubGVuZ3RoIC0gMSkgIT09ICd8JyB8fFxuICAgICAgcGFyYW1zU3RyaW5nLm1hdGNoKC9cXHwvZykhLmxlbmd0aCAhPT0gMlxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiSW52YWxpZCBibG9jayBwYXJhbWV0ZXJzIHN5bnRheDogJ1wiICsgcGFyYW1zU3RyaW5nICsgXCInXCIsIGVsZW1lbnQubG9jKTtcbiAgICB9XG5cbiAgICBsZXQgcGFyYW1zID0gW107XG4gICAgZm9yIChsZXQgaSA9IGFzSW5kZXggKyAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZXQgcGFyYW0gPSBhdHRyTmFtZXNbaV0ucmVwbGFjZSgvXFx8L2csICcnKTtcbiAgICAgIGlmIChwYXJhbSAhPT0gJycpIHtcbiAgICAgICAgaWYgKElEX0lOVkVSU0VfUEFUVEVSTi50ZXN0KHBhcmFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAgIFwiSW52YWxpZCBpZGVudGlmaWVyIGZvciBibG9jayBwYXJhbWV0ZXJzOiAnXCIgKyBwYXJhbSArIFwiJyBpbiAnXCIgKyBwYXJhbXNTdHJpbmcgKyBcIidcIixcbiAgICAgICAgICAgIGVsZW1lbnQubG9jXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgXCJDYW5ub3QgdXNlIHplcm8gYmxvY2sgcGFyYW1ldGVyczogJ1wiICsgcGFyYW1zU3RyaW5nICsgXCInXCIsXG4gICAgICAgIGVsZW1lbnQubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGVsZW1lbnQuYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcy5zbGljZSgwLCBhc0luZGV4KTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZHJlbkZvcihub2RlOiBBU1QuUHJvZ3JhbSB8IEFTVC5FbGVtZW50Tm9kZSk6IEFTVC5TdGF0ZW1lbnRbXSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAnUHJvZ3JhbSc6XG4gICAgICByZXR1cm4gbm9kZS5ib2R5O1xuICAgIGNhc2UgJ0VsZW1lbnROb2RlJzpcbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQ6IEFTVC5Qcm9ncmFtIHwgQVNULkVsZW1lbnROb2RlLCBub2RlOiBBU1QuU3RhdGVtZW50KSB7XG4gIGNoaWxkcmVuRm9yKHBhcmVudCkucHVzaChub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGl0ZXJhbChwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb24gfCBBU1QuTGl0ZXJhbCk6IHBhdGggaXMgQVNULkxpdGVyYWwge1xuICByZXR1cm4gKFxuICAgIHBhdGgudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnIHx8XG4gICAgcGF0aC50eXBlID09PSAnQm9vbGVhbkxpdGVyYWwnIHx8XG4gICAgcGF0aC50eXBlID09PSAnTnVtYmVyTGl0ZXJhbCcgfHxcbiAgICBwYXRoLnR5cGUgPT09ICdOdWxsTGl0ZXJhbCcgfHxcbiAgICBwYXRoLnR5cGUgPT09ICdVbmRlZmluZWRMaXRlcmFsJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRMaXRlcmFsKGxpdGVyYWw6IEFTVC5MaXRlcmFsKTogc3RyaW5nIHtcbiAgaWYgKGxpdGVyYWwudHlwZSA9PT0gJ1VuZGVmaW5lZExpdGVyYWwnKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShsaXRlcmFsLnZhbHVlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgRXZlbnRlZFRva2VuaXplcixcbiAgRW50aXR5UGFyc2VyLFxuICBIVE1MNU5hbWVkQ2hhclJlZnMgYXMgbmFtZWRDaGFyUmVmcyxcbn0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcbmltcG9ydCB7IFByb2dyYW0gfSBmcm9tICcuL3R5cGVzL25vZGVzJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuL3R5cGVzL25vZGVzJztcbmltcG9ydCAqIGFzIEhhbmRsZWJhcnNBU1QgZnJvbSAnLi90eXBlcy9oYW5kbGViYXJzLWFzdCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IGVudGl0eVBhcnNlciA9IG5ldyBFbnRpdHlQYXJzZXIobmFtZWRDaGFyUmVmcyk7XG5cbmV4cG9ydCB0eXBlIEVsZW1lbnQgPSBBU1QuUHJvZ3JhbSB8IEFTVC5FbGVtZW50Tm9kZTtcblxuZXhwb3J0IGludGVyZmFjZSBUYWc8VCBleHRlbmRzICdTdGFydFRhZycgfCAnRW5kVGFnJz4ge1xuICB0eXBlOiBUO1xuICBuYW1lOiBzdHJpbmc7XG4gIGF0dHJpYnV0ZXM6IGFueVtdO1xuICBtb2RpZmllcnM6IGFueVtdO1xuICBjb21tZW50czogYW55W107XG4gIHNlbGZDbG9zaW5nOiBib29sZWFuO1xuICBsb2M6IEFTVC5Tb3VyY2VMb2NhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHBhcnRzOiAoQVNULk11c3RhY2hlU3RhdGVtZW50IHwgQVNULlRleHROb2RlKVtdO1xuICBpc1F1b3RlZDogYm9vbGVhbjtcbiAgaXNEeW5hbWljOiBib29sZWFuO1xuICBzdGFydDogQVNULlBvc2l0aW9uO1xuICB2YWx1ZVN0YXJ0TGluZTogbnVtYmVyO1xuICB2YWx1ZVN0YXJ0Q29sdW1uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQYXJzZXIge1xuICBwcm90ZWN0ZWQgZWxlbWVudFN0YWNrOiBFbGVtZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBzb3VyY2U6IHN0cmluZ1tdO1xuICBwdWJsaWMgY3VycmVudEF0dHJpYnV0ZTogT3B0aW9uPEF0dHJpYnV0ZT4gPSBudWxsO1xuICBwdWJsaWMgY3VycmVudE5vZGU6IE9wdGlvbjxcbiAgICBBU1QuQ29tbWVudFN0YXRlbWVudCB8IEFTVC5UZXh0Tm9kZSB8IFRhZzwnU3RhcnRUYWcnIHwgJ0VuZFRhZyc+XG4gID4gPSBudWxsO1xuICBwdWJsaWMgdG9rZW5pemVyID0gbmV3IEV2ZW50ZWRUb2tlbml6ZXIodGhpcywgZW50aXR5UGFyc2VyKTtcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IHN0cmluZykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gIH1cblxuICBhYnN0cmFjdCByZXNldCgpOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hEYXRhKCk6IHZvaWQ7XG4gIGFic3RyYWN0IHRhZ09wZW4oKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5EYXRhKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGFwcGVuZFRvRGF0YShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpblN0YXJ0VGFnKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGFwcGVuZFRvVGFnTmFtZShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkF0dHJpYnV0ZSgpOiB2b2lkO1xuICBhYnN0cmFjdCBhcHBlbmRUb0F0dHJpYnV0ZU5hbWUoY2hhcjogc3RyaW5nKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5BdHRyaWJ1dGVWYWx1ZShxdW90ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICBhYnN0cmFjdCBhcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKGNoYXI6IHN0cmluZyk6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk6IHZvaWQ7XG4gIGFic3RyYWN0IG1hcmtUYWdBc1NlbGZDbG9zaW5nKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGJlZ2luRW5kVGFnKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaFRhZygpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkNvbW1lbnQoKTogdm9pZDtcbiAgYWJzdHJhY3QgYXBwZW5kVG9Db21tZW50RGF0YShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hDb21tZW50KCk6IHZvaWQ7XG4gIGFic3RyYWN0IHJlcG9ydFN5bnRheEVycm9yKGVycm9yOiBzdHJpbmcpOiB2b2lkO1xuXG4gIGdldCBjdXJyZW50QXR0cigpOiBBdHRyaWJ1dGUge1xuICAgIHJldHVybiBleHBlY3QodGhpcy5jdXJyZW50QXR0cmlidXRlLCAnZXhwZWN0ZWQgYXR0cmlidXRlJyk7XG4gIH1cblxuICBnZXQgY3VycmVudFRhZygpOiBUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPiB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIChub2RlLnR5cGUgPT09ICdTdGFydFRhZycgfHwgbm9kZS50eXBlID09PSAnRW5kVGFnJyksICdleHBlY3RlZCB0YWcnKTtcbiAgICByZXR1cm4gbm9kZSBhcyBUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPjtcbiAgfVxuXG4gIGdldCBjdXJyZW50U3RhcnRUYWcoKTogVGFnPCdTdGFydFRhZyc+IHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnU3RhcnRUYWcnLCAnZXhwZWN0ZWQgc3RhcnQgdGFnJyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgVGFnPCdTdGFydFRhZyc+O1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRFbmRUYWcoKTogVGFnPCdFbmRUYWcnPiB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ0VuZFRhZycsICdleHBlY3RlZCBlbmQgdGFnJyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgVGFnPCdFbmRUYWcnPjtcbiAgfVxuXG4gIGdldCBjdXJyZW50Q29tbWVudCgpOiBBU1QuQ29tbWVudFN0YXRlbWVudCB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ0NvbW1lbnRTdGF0ZW1lbnQnLCAnZXhwZWN0ZWQgYSBjb21tZW50Jyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgQVNULkNvbW1lbnRTdGF0ZW1lbnQ7XG4gIH1cblxuICBnZXQgY3VycmVudERhdGEoKTogQVNULlRleHROb2RlIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnVGV4dE5vZGUnLCAnZXhwZWN0ZWQgYSB0ZXh0IG5vZGUnKTtcbiAgICByZXR1cm4gbm9kZSBhcyBBU1QuVGV4dE5vZGU7XG4gIH1cblxuICBhY2NlcHROb2RlKG5vZGU6IEhhbmRsZWJhcnNBU1QuUHJvZ3JhbSk6IFByb2dyYW07XG4gIGFjY2VwdE5vZGU8VSBleHRlbmRzIEFTVC5Ob2RlPihub2RlOiBIYW5kbGViYXJzQVNULk5vZGUpOiBVO1xuICBhY2NlcHROb2RlKG5vZGU6IEhhbmRsZWJhcnNBU1QuTm9kZSk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXNbbm9kZS50eXBlXShub2RlKTtcbiAgfVxuXG4gIGN1cnJlbnRFbGVtZW50KCk6IEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFja1t0aGlzLmVsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHNvdXJjZUZvck5vZGUobm9kZTogSGFuZGxlYmFyc0FTVC5Ob2RlLCBlbmROb2RlPzogeyBsb2M6IEhhbmRsZWJhcnNBU1QuU291cmNlTG9jYXRpb24gfSk6IHN0cmluZyB7XG4gICAgbGV0IGZpcnN0TGluZSA9IG5vZGUubG9jLnN0YXJ0LmxpbmUgLSAxO1xuICAgIGxldCBjdXJyZW50TGluZSA9IGZpcnN0TGluZSAtIDE7XG4gICAgbGV0IGZpcnN0Q29sdW1uID0gbm9kZS5sb2Muc3RhcnQuY29sdW1uO1xuICAgIGxldCBzdHJpbmcgPSBbXTtcbiAgICBsZXQgbGluZTtcblxuICAgIGxldCBsYXN0TGluZTogbnVtYmVyO1xuICAgIGxldCBsYXN0Q29sdW1uOiBudW1iZXI7XG5cbiAgICBpZiAoZW5kTm9kZSkge1xuICAgICAgbGFzdExpbmUgPSBlbmROb2RlLmxvYy5lbmQubGluZSAtIDE7XG4gICAgICBsYXN0Q29sdW1uID0gZW5kTm9kZS5sb2MuZW5kLmNvbHVtbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdExpbmUgPSBub2RlLmxvYy5lbmQubGluZSAtIDE7XG4gICAgICBsYXN0Q29sdW1uID0gbm9kZS5sb2MuZW5kLmNvbHVtbjtcbiAgICB9XG5cbiAgICB3aGlsZSAoY3VycmVudExpbmUgPCBsYXN0TGluZSkge1xuICAgICAgY3VycmVudExpbmUrKztcbiAgICAgIGxpbmUgPSB0aGlzLnNvdXJjZVtjdXJyZW50TGluZV07XG5cbiAgICAgIGlmIChjdXJyZW50TGluZSA9PT0gZmlyc3RMaW5lKSB7XG4gICAgICAgIGlmIChmaXJzdExpbmUgPT09IGxhc3RMaW5lKSB7XG4gICAgICAgICAgc3RyaW5nLnB1c2gobGluZS5zbGljZShmaXJzdENvbHVtbiwgbGFzdENvbHVtbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmluZy5wdXNoKGxpbmUuc2xpY2UoZmlyc3RDb2x1bW4pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGluZSA9PT0gbGFzdExpbmUpIHtcbiAgICAgICAgc3RyaW5nLnB1c2gobGluZS5zbGljZSgwLCBsYXN0Q29sdW1uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmcucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nLmpvaW4oJ1xcbicpO1xuICB9XG59XG4iLCJpbXBvcnQgYiBmcm9tICcuLi9idWlsZGVycyc7XG5pbXBvcnQgeyBhcHBlbmRDaGlsZCwgaXNMaXRlcmFsLCBwcmludExpdGVyYWwgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0ICogYXMgSGFuZGxlYmFyc0FTVCBmcm9tICcuLi90eXBlcy9oYW5kbGViYXJzLWFzdCc7XG5pbXBvcnQgeyBQYXJzZXIsIFRhZywgQXR0cmlidXRlIH0gZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCBTeW50YXhFcnJvciBmcm9tICcuLi9lcnJvcnMvc3ludGF4LWVycm9yJztcbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgUmVjYXN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBUb2tlbml6ZXJTdGF0ZSB9IGZyb20gJ3NpbXBsZS1odG1sLXRva2VuaXplcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBIYW5kbGViYXJzTm9kZVZpc2l0b3JzIGV4dGVuZHMgUGFyc2VyIHtcbiAgYWJzdHJhY3QgYXBwZW5kVG9Db21tZW50RGF0YShzOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkF0dHJpYnV0ZVZhbHVlKHF1b3RlZDogYm9vbGVhbik6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk6IHZvaWQ7XG5cbiAgY3Vyc29yQ291bnQgPSAwO1xuXG4gIGN1cnNvcigpIHtcbiAgICByZXR1cm4gYCVjdXJzb3I6JHt0aGlzLmN1cnNvckNvdW50Kyt9JWA7XG4gIH1cblxuICBQcm9ncmFtKHByb2dyYW06IEhhbmRsZWJhcnNBU1QuUHJvZ3JhbSk6IEFTVC5Qcm9ncmFtIHtcbiAgICBsZXQgYm9keTogQVNULlN0YXRlbWVudFtdID0gW107XG4gICAgdGhpcy5jdXJzb3JDb3VudCA9IDA7XG4gICAgbGV0IG5vZGUgPSBiLnByb2dyYW0oYm9keSwgcHJvZ3JhbS5ibG9ja1BhcmFtcywgcHJvZ3JhbS5sb2MpO1xuICAgIGxldCBpLFxuICAgICAgbCA9IHByb2dyYW0uYm9keS5sZW5ndGg7XG5cbiAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKSBhcyBBU1QuUHJvZ3JhbTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLmFjY2VwdE5vZGUocHJvZ3JhbS5ib2R5W2ldKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGF0IHRoZSBlbGVtZW50IHN0YWNrIGlzIGJhbGFuY2VkIHByb3Blcmx5LlxuICAgIGxldCBwb3BwZWROb2RlID0gdGhpcy5lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgaWYgKHBvcHBlZE5vZGUgIT09IG5vZGUpIHtcbiAgICAgIGxldCBlbGVtZW50Tm9kZSA9IHBvcHBlZE5vZGUgYXMgQVNULkVsZW1lbnROb2RlO1xuXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICdVbmNsb3NlZCBlbGVtZW50IGAnICsgZWxlbWVudE5vZGUudGFnICsgJ2AgKG9uIGxpbmUgJyArIGVsZW1lbnROb2RlLmxvYyEuc3RhcnQubGluZSArICcpLicsXG4gICAgICAgIGVsZW1lbnROb2RlLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIEJsb2NrU3RhdGVtZW50KGJsb2NrOiBIYW5kbGViYXJzQVNULkJsb2NrU3RhdGVtZW50KSB7XG4gICAgaWYgKHRoaXMudG9rZW5pemVyWydzdGF0ZSddID09PSAnY29tbWVudCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUoYmxvY2spKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2NvbW1lbnQnICYmXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2RhdGEnICYmXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2JlZm9yZURhdGEnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICdBIGJsb2NrIG1heSBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIEhUTUwgZWxlbWVudCBvciBhbm90aGVyIGJsb2NrLicsXG4gICAgICAgIGJsb2NrLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBibG9jayk7XG4gICAgbGV0IHByb2dyYW0gPSB0aGlzLlByb2dyYW0oYmxvY2sucHJvZ3JhbSk7XG4gICAgbGV0IGludmVyc2UgPSBibG9jay5pbnZlcnNlID8gdGhpcy5Qcm9ncmFtKGJsb2NrLmludmVyc2UpIDogbnVsbDtcblxuICAgIGlmIChwYXRoLm9yaWdpbmFsID09PSAnaW4tZWxlbWVudCcpIHtcbiAgICAgIGhhc2ggPSBhZGRJbkVsZW1lbnRIYXNoKHRoaXMuY3Vyc29yKCksIGhhc2gsIGJsb2NrLmxvYyk7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBiLmJsb2NrKHBhdGgsIHBhcmFtcywgaGFzaCwgcHJvZ3JhbSwgaW52ZXJzZSwgYmxvY2subG9jKTtcblxuICAgIGxldCBwYXJlbnRQcm9ncmFtID0gdGhpcy5jdXJyZW50RWxlbWVudCgpO1xuICAgIGFwcGVuZENoaWxkKHBhcmVudFByb2dyYW0sIG5vZGUpO1xuICB9XG5cbiAgTXVzdGFjaGVTdGF0ZW1lbnQocmF3TXVzdGFjaGU6IEhhbmRsZWJhcnNBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgICBsZXQgeyB0b2tlbml6ZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAodG9rZW5pemVyWydzdGF0ZSddID09PSAnY29tbWVudCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUocmF3TXVzdGFjaGUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudDtcbiAgICBsZXQgeyBlc2NhcGVkLCBsb2MgfSA9IHJhd011c3RhY2hlO1xuXG4gICAgaWYgKHJhd011c3RhY2hlLnBhdGgudHlwZS5tYXRjaCgvTGl0ZXJhbCQvKSkge1xuICAgICAgbXVzdGFjaGUgPSB7XG4gICAgICAgIHR5cGU6ICdNdXN0YWNoZVN0YXRlbWVudCcsXG4gICAgICAgIHBhdGg6IHRoaXMuYWNjZXB0Tm9kZTxBU1QuTGl0ZXJhbD4ocmF3TXVzdGFjaGUucGF0aCksXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIGhhc2g6IGIuaGFzaCgpLFxuICAgICAgICBlc2NhcGVkLFxuICAgICAgICBsb2MsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2RlcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmF3TXVzdGFjaGUgYXMgSGFuZGxlYmFyc0FTVC5NdXN0YWNoZVN0YXRlbWVudCAmIHtcbiAgICAgICAgICBwYXRoOiBIYW5kbGViYXJzQVNULlBhdGhFeHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbXVzdGFjaGUgPSBiLm11c3RhY2hlKHBhdGgsIHBhcmFtcywgaGFzaCwgIWVzY2FwZWQsIGxvYyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgIC8vIFRhZyBoZWxwZXJzXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLnRhZ05hbWU6XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZTpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVOYW1lOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hZnRlckF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIHRoaXMuZmluaXNoQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hZnRlckF0dHJpYnV0ZVZhbHVlUXVvdGVkOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIEF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlVmFsdWU6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQodGhpcy5jdXJyZW50QXR0cmlidXRlISwgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlVW5xdW90ZWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZWQ6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVkOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVVucXVvdGVkOlxuICAgICAgICBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KHRoaXMuY3VycmVudEF0dHJpYnV0ZSEsIG11c3RhY2hlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFRPRE86IE9ubHkgYXBwZW5kIGNoaWxkIHdoZW4gdGhlIHRva2VuaXplciBzdGF0ZSBtYWtlc1xuICAgICAgLy8gc2Vuc2UgdG8gZG8gc28sIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgbXVzdGFjaGUpO1xuICAgIH1cblxuICAgIHJldHVybiBtdXN0YWNoZTtcbiAgfVxuXG4gIENvbnRlbnRTdGF0ZW1lbnQoY29udGVudDogSGFuZGxlYmFyc0FTVC5Db250ZW50U3RhdGVtZW50KSB7XG4gICAgdXBkYXRlVG9rZW5pemVyTG9jYXRpb24odGhpcy50b2tlbml6ZXIsIGNvbnRlbnQpO1xuXG4gICAgdGhpcy50b2tlbml6ZXIudG9rZW5pemVQYXJ0KGNvbnRlbnQudmFsdWUpO1xuICAgIHRoaXMudG9rZW5pemVyLmZsdXNoRGF0YSgpO1xuICB9XG5cbiAgQ29tbWVudFN0YXRlbWVudChcbiAgICByYXdDb21tZW50OiBIYW5kbGViYXJzQVNULkNvbW1lbnRTdGF0ZW1lbnRcbiAgKTogT3B0aW9uPEFTVC5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQ+IHtcbiAgICBsZXQgeyB0b2tlbml6ZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAodG9rZW5pemVyLnN0YXRlID09PSBUb2tlbml6ZXJTdGF0ZS5jb21tZW50KSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd0NvbW1lbnQpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCB7IHZhbHVlLCBsb2MgfSA9IHJhd0NvbW1lbnQ7XG4gICAgbGV0IGNvbW1lbnQgPSBiLm11c3RhY2hlQ29tbWVudCh2YWx1ZSwgbG9jKTtcblxuICAgIHN3aXRjaCAodG9rZW5pemVyLnN0YXRlKSB7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXJ0VGFnLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZURhdGE6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmRhdGE6XG4gICAgICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgY29tbWVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVzaW5nIGEgSGFuZGxlYmFycyBjb21tZW50IHdoZW4gaW4gdGhlIFxcYCR7XG4gICAgICAgICAgICB0b2tlbml6ZXJbJ3N0YXRlJ11cbiAgICAgICAgICB9XFxgIHN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQ6IFwiJHtjb21tZW50LnZhbHVlfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX06JHtcbiAgICAgICAgICAgIGxvYy5zdGFydC5jb2x1bW5cbiAgICAgICAgICB9YCxcbiAgICAgICAgICByYXdDb21tZW50LmxvY1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50O1xuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsOiBIYW5kbGViYXJzQVNULlBhcnRpYWxTdGF0ZW1lbnQpIHtcbiAgICBsZXQgeyBsb2MgfSA9IHBhcnRpYWw7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFscyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShwYXJ0aWFsLCBwYXJ0aWFsLm5hbWUpfVwiIGF0IEwke1xuICAgICAgICBsb2Muc3RhcnQubGluZVxuICAgICAgfTpDJHtsb2Muc3RhcnQuY29sdW1ufWAsXG4gICAgICBwYXJ0aWFsLmxvY1xuICAgICk7XG4gIH1cblxuICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQocGFydGlhbEJsb2NrOiBIYW5kbGViYXJzQVNULlBhcnRpYWxCbG9ja1N0YXRlbWVudCkge1xuICAgIGxldCB7IGxvYyB9ID0gcGFydGlhbEJsb2NrO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgcGFydGlhbCBibG9ja3MgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgIHBhcnRpYWxCbG9jayxcbiAgICAgICAgcGFydGlhbEJsb2NrLm5hbWVcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIHBhcnRpYWxCbG9jay5sb2NcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yKGRlY29yYXRvcjogSGFuZGxlYmFyc0FTVC5EZWNvcmF0b3IpIHtcbiAgICBsZXQgeyBsb2MgfSA9IGRlY29yYXRvcjtcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIGRlY29yYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgIGRlY29yYXRvcixcbiAgICAgICAgZGVjb3JhdG9yLnBhdGhcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIGRlY29yYXRvci5sb2NcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yQmxvY2soZGVjb3JhdG9yQmxvY2s6IEhhbmRsZWJhcnNBU1QuRGVjb3JhdG9yQmxvY2spIHtcbiAgICBsZXQgeyBsb2MgfSA9IGRlY29yYXRvckJsb2NrO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgZGVjb3JhdG9yIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgZGVjb3JhdG9yQmxvY2ssXG4gICAgICAgIGRlY29yYXRvckJsb2NrLnBhdGhcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIGRlY29yYXRvckJsb2NrLmxvY1xuICAgICk7XG4gIH1cblxuICBTdWJFeHByZXNzaW9uKHNleHByOiBIYW5kbGViYXJzQVNULlN1YkV4cHJlc3Npb24pOiBBU1QuU3ViRXhwcmVzc2lvbiB7XG4gICAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoIH0gPSBhY2NlcHRDYWxsTm9kZXModGhpcywgc2V4cHIpO1xuICAgIHJldHVybiBiLnNleHByKHBhdGgsIHBhcmFtcywgaGFzaCwgc2V4cHIubG9jKTtcbiAgfVxuXG4gIFBhdGhFeHByZXNzaW9uKHBhdGg6IEhhbmRsZWJhcnNBU1QuUGF0aEV4cHJlc3Npb24pOiBBU1QuUGF0aEV4cHJlc3Npb24ge1xuICAgIGxldCB7IG9yaWdpbmFsLCBsb2MgfSA9IHBhdGg7XG4gICAgbGV0IHBhcnRzOiBzdHJpbmdbXTtcblxuICAgIGlmIChvcmlnaW5hbC5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICBpZiAob3JpZ2luYWwuc2xpY2UoMCwgMikgPT09ICcuLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBVc2luZyBcIi4vXCIgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyIGFuZCB1bm5lY2Vzc2FyeTogXCIke3BhdGgub3JpZ2luYWx9XCIgb24gbGluZSAke1xuICAgICAgICAgICAgbG9jLnN0YXJ0LmxpbmVcbiAgICAgICAgICB9LmAsXG4gICAgICAgICAgcGF0aC5sb2NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnaW5hbC5zbGljZSgwLCAzKSA9PT0gJy4uLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBDaGFuZ2luZyBjb250ZXh0IHVzaW5nIFwiLi4vXCIgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOiBcIiR7cGF0aC5vcmlnaW5hbH1cIiBvbiBsaW5lICR7XG4gICAgICAgICAgICBsb2Muc3RhcnQubGluZVxuICAgICAgICAgIH0uYCxcbiAgICAgICAgICBwYXRoLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBNaXhpbmcgJy4nIGFuZCAnLycgaW4gcGF0aHMgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOyB1c2Ugb25seSAnLicgdG8gc2VwYXJhdGUgcHJvcGVydHkgcGF0aHM6IFwiJHtcbiAgICAgICAgICAgIHBhdGgub3JpZ2luYWxcbiAgICAgICAgICB9XCIgb24gbGluZSAke2xvYy5zdGFydC5saW5lfS5gLFxuICAgICAgICAgIHBhdGgubG9jXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwYXJ0cyA9IFtwYXRoLnBhcnRzLmpvaW4oJy8nKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzID0gcGF0aC5wYXJ0cztcbiAgICB9XG5cbiAgICBsZXQgdGhpc0hlYWQgPSBmYWxzZTtcblxuICAgIC8vIFRoaXMgaXMgdG8gZml4IGEgYnVnIGluIHRoZSBIYW5kbGViYXJzIEFTVCB3aGVyZSB0aGUgcGF0aCBleHByZXNzaW9ucyBpblxuICAgIC8vIGB7e3RoaXMuZm9vfX1gIChhbmQgc2ltaWxhcmx5IGB7e2Zvby1iYXIgdGhpcy5mb28gbmFtZWQ9dGhpcy5mb299fWAgZXRjKVxuICAgIC8vIGFyZSBzaW1wbHkgdHVybmVkIGludG8gYHt7Zm9vfX1gLiBUaGUgZml4IGlzIHRvIHB1c2ggaXQgYmFjayBvbnRvIHRoZVxuICAgIC8vIHBhcnRzIGFycmF5IGFuZCBsZXQgdGhlIHJ1bnRpbWUgc2VlIHRoZSBkaWZmZXJlbmNlLiBIb3dldmVyLCB3ZSBjYW5ub3RcbiAgICAvLyBzaW1wbHkgdXNlIHRoZSBzdHJpbmcgYHRoaXNgIGFzIGl0IG1lYW5zIGxpdGVyYWxseSB0aGUgcHJvcGVydHkgY2FsbGVkXG4gICAgLy8gXCJ0aGlzXCIgaW4gdGhlIGN1cnJlbnQgY29udGV4dCAoaXQgY2FuIGJlIGV4cHJlc3NlZCBpbiB0aGUgc3ludGF4IGFzXG4gICAgLy8gYHt7W3RoaXNdfX1gLCB3aGVyZSB0aGUgc3F1YXJlIGJyYWNrZXQgYXJlIGdlbmVyYWxseSBmb3IgdGhpcyBraW5kIG9mXG4gICAgLy8gZXNjYXBpbmcgw6LCgMKTIHN1Y2ggYXMgYHt7Zm9vLltcImJhci5iYXpcIl19fWAgd291bGQgbWVhbiBsb29rdXAgYSBwcm9wZXJ0eVxuICAgIC8vIG5hbWVkIGxpdGVyYWxseSBcImJhci5iYXpcIiBvbiBgdGhpcy5mb29gKS4gQnkgY29udmVudGlvbiwgd2UgdXNlIGBudWxsYFxuICAgIC8vIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgaWYgKG9yaWdpbmFsLm1hdGNoKC9edGhpcyhcXC4uKyk/JC8pKSB7XG4gICAgICB0aGlzSGVhZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXG4gICAgICBvcmlnaW5hbDogcGF0aC5vcmlnaW5hbCxcbiAgICAgIHRoaXM6IHRoaXNIZWFkLFxuICAgICAgcGFydHMsXG4gICAgICBkYXRhOiBwYXRoLmRhdGEsXG4gICAgICBsb2M6IHBhdGgubG9jLFxuICAgIH07XG4gIH1cblxuICBIYXNoKGhhc2g6IEhhbmRsZWJhcnNBU1QuSGFzaCk6IEFTVC5IYXNoIHtcbiAgICBsZXQgcGFpcnM6IEFTVC5IYXNoUGFpcltdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhc2gucGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwYWlyID0gaGFzaC5wYWlyc1tpXTtcbiAgICAgIHBhaXJzLnB1c2goYi5wYWlyKHBhaXIua2V5LCB0aGlzLmFjY2VwdE5vZGU8QVNULkV4cHJlc3Npb24+KHBhaXIudmFsdWUpLCBwYWlyLmxvYykpO1xuICAgIH1cblxuICAgIHJldHVybiBiLmhhc2gocGFpcnMsIGhhc2gubG9jKTtcbiAgfVxuXG4gIFN0cmluZ0xpdGVyYWwoc3RyaW5nOiBIYW5kbGViYXJzQVNULlN0cmluZ0xpdGVyYWwpIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdTdHJpbmdMaXRlcmFsJywgc3RyaW5nLnZhbHVlLCBzdHJpbmcubG9jKTtcbiAgfVxuXG4gIEJvb2xlYW5MaXRlcmFsKGJvb2xlYW46IEhhbmRsZWJhcnNBU1QuQm9vbGVhbkxpdGVyYWwpIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdCb29sZWFuTGl0ZXJhbCcsIGJvb2xlYW4udmFsdWUsIGJvb2xlYW4ubG9jKTtcbiAgfVxuXG4gIE51bWJlckxpdGVyYWwobnVtYmVyOiBIYW5kbGViYXJzQVNULk51bWJlckxpdGVyYWwpIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdOdW1iZXJMaXRlcmFsJywgbnVtYmVyLnZhbHVlLCBudW1iZXIubG9jKTtcbiAgfVxuXG4gIFVuZGVmaW5lZExpdGVyYWwodW5kZWY6IEhhbmRsZWJhcnNBU1QuVW5kZWZpbmVkTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ1VuZGVmaW5lZExpdGVyYWwnLCB1bmRlZmluZWQsIHVuZGVmLmxvYyk7XG4gIH1cblxuICBOdWxsTGl0ZXJhbChudWw6IEhhbmRsZWJhcnNBU1QuTnVsbExpdGVyYWwpIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdOdWxsTGl0ZXJhbCcsIG51bGwsIG51bC5sb2MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKG9yaWdpbmFsOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIC8vIGlmIGl0IGlzIGVtcHR5LCBqdXN0IHJldHVybiB0aGUgY291bnQgb2YgbmV3bGluZXNcbiAgICAvLyBpbiBvcmlnaW5hbFxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogb3JpZ2luYWwuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDEsXG4gICAgICBjb2x1bW5zOiAwLFxuICAgIH07XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIG5ld2xpbmVzIHByaW9yIHRvXG4gIC8vIGB2YWx1ZWBcbiAgbGV0IGRpZmZlcmVuY2UgPSBvcmlnaW5hbC5zcGxpdCh2YWx1ZSlbMF07XG4gIGxldCBsaW5lcyA9IGRpZmZlcmVuY2Uuc3BsaXQoL1xcbi8pO1xuICBsZXQgbGluZUNvdW50ID0gbGluZXMubGVuZ3RoIC0gMTtcblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lQ291bnQsXG4gICAgY29sdW1uczogbGluZXNbbGluZUNvdW50XS5sZW5ndGgsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRva2VuaXplckxvY2F0aW9uKFxuICB0b2tlbml6ZXI6IFBhcnNlclsndG9rZW5pemVyJ10sXG4gIGNvbnRlbnQ6IEhhbmRsZWJhcnNBU1QuQ29udGVudFN0YXRlbWVudFxuKSB7XG4gIGxldCBsaW5lID0gY29udGVudC5sb2Muc3RhcnQubGluZTtcbiAgbGV0IGNvbHVtbiA9IGNvbnRlbnQubG9jLnN0YXJ0LmNvbHVtbjtcblxuICBsZXQgb2Zmc2V0cyA9IGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKFxuICAgIGNvbnRlbnQub3JpZ2luYWwgYXMgUmVjYXN0PEhhbmRsZWJhcnNBU1QuU3RyaXBGbGFncywgc3RyaW5nPixcbiAgICBjb250ZW50LnZhbHVlXG4gICk7XG5cbiAgbGluZSA9IGxpbmUgKyBvZmZzZXRzLmxpbmVzO1xuICBpZiAob2Zmc2V0cy5saW5lcykge1xuICAgIGNvbHVtbiA9IG9mZnNldHMuY29sdW1ucztcbiAgfSBlbHNlIHtcbiAgICBjb2x1bW4gPSBjb2x1bW4gKyBvZmZzZXRzLmNvbHVtbnM7XG4gIH1cblxuICB0b2tlbml6ZXIubGluZSA9IGxpbmU7XG4gIHRva2VuaXplci5jb2x1bW4gPSBjb2x1bW47XG59XG5cbmZ1bmN0aW9uIGFjY2VwdENhbGxOb2RlcyhcbiAgY29tcGlsZXI6IEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMsXG4gIG5vZGU6IHtcbiAgICBwYXRoOiBIYW5kbGViYXJzQVNULlBhdGhFeHByZXNzaW9uO1xuICAgIHBhcmFtczogSGFuZGxlYmFyc0FTVC5FeHByZXNzaW9uW107XG4gICAgaGFzaDogSGFuZGxlYmFyc0FTVC5IYXNoO1xuICB9XG4pOiB7IHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbjsgcGFyYW1zOiBBU1QuRXhwcmVzc2lvbltdOyBoYXNoOiBBU1QuSGFzaCB9IHtcbiAgbGV0IHBhdGggPSBjb21waWxlci5QYXRoRXhwcmVzc2lvbihub2RlLnBhdGgpO1xuXG4gIGxldCBwYXJhbXMgPSBub2RlLnBhcmFtcyA/IG5vZGUucGFyYW1zLm1hcChlID0+IGNvbXBpbGVyLmFjY2VwdE5vZGU8QVNULkV4cHJlc3Npb24+KGUpKSA6IFtdO1xuICBsZXQgaGFzaCA9IG5vZGUuaGFzaCA/IGNvbXBpbGVyLkhhc2gobm9kZS5oYXNoKSA6IGIuaGFzaCgpO1xuXG4gIHJldHVybiB7IHBhdGgsIHBhcmFtcywgaGFzaCB9O1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50TW9kaWZpZXIoZWxlbWVudDogVGFnPCdTdGFydFRhZyc+LCBtdXN0YWNoZTogQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jIH0gPSBtdXN0YWNoZTtcblxuICBpZiAoaXNMaXRlcmFsKHBhdGgpKSB7XG4gICAgbGV0IG1vZGlmaWVyID0gYHt7JHtwcmludExpdGVyYWwocGF0aCl9fX1gO1xuICAgIGxldCB0YWcgPSBgPCR7ZWxlbWVudC5uYW1lfSAuLi4gJHttb2RpZmllcn0gLi4uYDtcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBJbiAke3RhZ30sICR7bW9kaWZpZXJ9IGlzIG5vdCBhIHZhbGlkIG1vZGlmaWVyOiBcIiR7cGF0aC5vcmlnaW5hbH1cIiBvbiBsaW5lICR7bG9jICYmXG4gICAgICAgIGxvYy5zdGFydC5saW5lfS5gLFxuICAgICAgbXVzdGFjaGUubG9jXG4gICAgKTtcbiAgfVxuXG4gIGxldCBtb2RpZmllciA9IGIuZWxlbWVudE1vZGlmaWVyKHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jKTtcbiAgZWxlbWVudC5tb2RpZmllcnMucHVzaChtb2RpZmllcik7XG59XG5cbmZ1bmN0aW9uIGFkZEluRWxlbWVudEhhc2goY3Vyc29yOiBzdHJpbmcsIGhhc2g6IEFTVC5IYXNoLCBsb2M6IEFTVC5Tb3VyY2VMb2NhdGlvbikge1xuICBsZXQgaGFzTmV4dFNpYmxpbmcgPSBmYWxzZTtcbiAgaGFzaC5wYWlycy5mb3JFYWNoKHBhaXIgPT4ge1xuICAgIGlmIChwYWlyLmtleSA9PT0gJ2d1aWQnKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCBwYXNzIGBndWlkYCBmcm9tIHVzZXIgc3BhY2UnLCBsb2MpO1xuICAgIH1cblxuICAgIGlmIChwYWlyLmtleSA9PT0gJ25leHRTaWJsaW5nJykge1xuICAgICAgaGFzTmV4dFNpYmxpbmcgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGd1aWQgPSBiLmxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnLCBjdXJzb3IpO1xuICBsZXQgZ3VpZFBhaXIgPSBiLnBhaXIoJ2d1aWQnLCBndWlkKTtcbiAgaGFzaC5wYWlycy51bnNoaWZ0KGd1aWRQYWlyKTtcblxuICBpZiAoIWhhc05leHRTaWJsaW5nKSB7XG4gICAgbGV0IG51bGxMaXRlcmFsID0gYi5saXRlcmFsKCdOdWxsTGl0ZXJhbCcsIG51bGwpO1xuICAgIGxldCBuZXh0U2libGluZyA9IGIucGFpcignbmV4dFNpYmxpbmcnLCBudWxsTGl0ZXJhbCk7XG4gICAgaGFzaC5wYWlycy5wdXNoKG5leHRTaWJsaW5nKTtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KGF0dHJpYnV0ZTogQXR0cmlidXRlLCBwYXJ0OiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgYXR0cmlidXRlLmlzRHluYW1pYyA9IHRydWU7XG4gIGF0dHJpYnV0ZS5wYXJ0cy5wdXNoKHBhcnQpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBQcm9ncmFtOiBbJ2JvZHknXSxcblxuICBNdXN0YWNoZVN0YXRlbWVudDogWydwYXRoJywgJ3BhcmFtcycsICdoYXNoJ10sXG4gIEJsb2NrU3RhdGVtZW50OiBbJ3BhdGgnLCAncGFyYW1zJywgJ2hhc2gnLCAncHJvZ3JhbScsICdpbnZlcnNlJ10sXG4gIEVsZW1lbnRNb2RpZmllclN0YXRlbWVudDogWydwYXRoJywgJ3BhcmFtcycsICdoYXNoJ10sXG4gIFBhcnRpYWxTdGF0ZW1lbnQ6IFsnbmFtZScsICdwYXJhbXMnLCAnaGFzaCddLFxuICBDb21tZW50U3RhdGVtZW50OiBbXSxcbiAgTXVzdGFjaGVDb21tZW50U3RhdGVtZW50OiBbXSxcbiAgRWxlbWVudE5vZGU6IFsnYXR0cmlidXRlcycsICdtb2RpZmllcnMnLCAnY2hpbGRyZW4nLCAnY29tbWVudHMnXSxcbiAgQXR0ck5vZGU6IFsndmFsdWUnXSxcbiAgVGV4dE5vZGU6IFtdLFxuXG4gIENvbmNhdFN0YXRlbWVudDogWydwYXJ0cyddLFxuICBTdWJFeHByZXNzaW9uOiBbJ3BhdGgnLCAncGFyYW1zJywgJ2hhc2gnXSxcbiAgUGF0aEV4cHJlc3Npb246IFtdLFxuXG4gIFN0cmluZ0xpdGVyYWw6IFtdLFxuICBCb29sZWFuTGl0ZXJhbDogW10sXG4gIE51bWJlckxpdGVyYWw6IFtdLFxuICBOdWxsTGl0ZXJhbDogW10sXG4gIFVuZGVmaW5lZExpdGVyYWw6IFtdLFxuXG4gIEhhc2g6IFsncGFpcnMnXSxcbiAgSGFzaFBhaXI6IFsndmFsdWUnXSxcbn07XG4iLCJpbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhdmVyc2FsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yOiBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yO1xuICBrZXk6IHN0cmluZztcbiAgbm9kZTogQVNULk5vZGU7XG4gIHBhcmVudDogT3B0aW9uPEFTVC5Ob2RlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yIHtcbiAgbmV3IChtZXNzYWdlOiBzdHJpbmcsIG5vZGU6IEFTVC5Ob2RlLCBwYXJlbnQ6IE9wdGlvbjxBU1QuTm9kZT4sIGtleTogc3RyaW5nKTogVHJhdmVyc2FsRXJyb3I7XG4gIHJlYWRvbmx5IHByb3RvdHlwZTogVHJhdmVyc2FsRXJyb3I7XG59XG5cbmNvbnN0IFRyYXZlcnNhbEVycm9yOiBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yID0gKGZ1bmN0aW9uKCkge1xuICBUcmF2ZXJzYWxFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIFRyYXZlcnNhbEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYXZlcnNhbEVycm9yO1xuXG4gIGZ1bmN0aW9uIFRyYXZlcnNhbEVycm9yKFxuICAgIHRoaXM6IFRyYXZlcnNhbEVycm9yLFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBub2RlOiBBU1QuTm9kZSxcbiAgICBwYXJlbnQ6IE9wdGlvbjxBU1QuTm9kZT4sXG4gICAga2V5OiBzdHJpbmdcbiAgKSB7XG4gICAgbGV0IGVycm9yID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gIH1cblxuICByZXR1cm4gVHJhdmVyc2FsRXJyb3IgYXMgYW55O1xufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgVHJhdmVyc2FsRXJyb3I7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RSZW1vdmVOb2RlKG5vZGU6IEFTVC5Ob2RlLCBwYXJlbnQ6IEFTVC5Ob2RlLCBrZXk6IHN0cmluZykge1xuICByZXR1cm4gbmV3IFRyYXZlcnNhbEVycm9yKFxuICAgICdDYW5ub3QgcmVtb3ZlIGEgbm9kZSB1bmxlc3MgaXQgaXMgcGFydCBvZiBhbiBhcnJheScsXG4gICAgbm9kZSxcbiAgICBwYXJlbnQsXG4gICAga2V5XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RSZXBsYWNlTm9kZShub2RlOiBBU1QuTm9kZSwgcGFyZW50OiBBU1QuTm9kZSwga2V5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBUcmF2ZXJzYWxFcnJvcihcbiAgICAnQ2Fubm90IHJlcGxhY2UgYSBub2RlIHdpdGggbXVsdGlwbGUgbm9kZXMgdW5sZXNzIGl0IGlzIHBhcnQgb2YgYW4gYXJyYXknLFxuICAgIG5vZGUsXG4gICAgcGFyZW50LFxuICAgIGtleVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2Fubm90UmVwbGFjZU9yUmVtb3ZlSW5LZXlIYW5kbGVyWWV0KG5vZGU6IEFTVC5Ob2RlLCBrZXk6IHN0cmluZykge1xuICByZXR1cm4gbmV3IFRyYXZlcnNhbEVycm9yKFxuICAgICdSZXBsYWNpbmcgYW5kIHJlbW92aW5nIGluIGtleSBoYW5kbGVycyBpcyBub3QgeWV0IHN1cHBvcnRlZC4nLFxuICAgIG5vZGUsXG4gICAgbnVsbCxcbiAgICBrZXlcbiAgKTtcbn1cbiIsImltcG9ydCB2aXNpdG9yS2V5cyBmcm9tICcuLi90eXBlcy92aXNpdG9yLWtleXMnO1xuaW1wb3J0IHtcbiAgY2Fubm90UmVtb3ZlTm9kZSxcbiAgY2Fubm90UmVwbGFjZU5vZGUsXG4gIGNhbm5vdFJlcGxhY2VPclJlbW92ZUluS2V5SGFuZGxlcllldCxcbn0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0ICogYXMgbm9kZXMgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuXG5leHBvcnQgdHlwZSBOb2RlSGFuZGxlcjxUIGV4dGVuZHMgbm9kZXMuTm9kZT4gPSBOb2RlSGFuZGxlckZ1bmN0aW9uPFQ+IHwgRW50ZXJFeGl0Tm9kZUhhbmRsZXI8VD47XG5cbmV4cG9ydCB0eXBlIFNwZWNpZmljTm9kZVZpc2l0b3IgPSB7IFtQIGluIGtleW9mIG5vZGVzLk5vZGVzXT86IE5vZGVIYW5kbGVyPG5vZGVzLk5vZGVzW1BdPiB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVWaXNpdG9yIGV4dGVuZHMgU3BlY2lmaWNOb2RlVmlzaXRvciB7XG4gIEFsbD86IE5vZGVIYW5kbGVyPG5vZGVzLk5vZGU+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVIYW5kbGVyRnVuY3Rpb248VCBleHRlbmRzIG5vZGVzLk5vZGU+IHtcbiAgKHRoaXM6IG51bGwsIG5vZGU6IFQpOiBhbnkgfCBudWxsIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVudGVyRXhpdE5vZGVIYW5kbGVyPFQgZXh0ZW5kcyBub2Rlcy5Ob2RlPiB7XG4gIGVudGVyPzogTm9kZUhhbmRsZXJGdW5jdGlvbjxUPjtcbiAgZXhpdD86IE5vZGVIYW5kbGVyRnVuY3Rpb248VD47XG4gIGtleXM/OiBhbnk7XG59XG5cbmZ1bmN0aW9uIHZpc2l0Tm9kZSh2aXNpdG9yOiBOb2RlVmlzaXRvciwgbm9kZTogbm9kZXMuTm9kZSk6IGFueSB7XG4gIGxldCBoYW5kbGVyID0gdmlzaXRvcltub2RlLnR5cGVdIHx8IHZpc2l0b3IuQWxsIHx8IG51bGw7XG4gIGxldCByZXN1bHQ7XG5cbiAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlclsnZW50ZXInXSkge1xuICAgIHJlc3VsdCA9IGhhbmRsZXJbJ2VudGVyJ10uY2FsbChudWxsLCBub2RlKTtcbiAgfVxuXG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkobm9kZSkgPT09IEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHZpc2l0QXJyYXkodmlzaXRvciwgcmVzdWx0KSB8fCByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aXNpdE5vZGUodmlzaXRvciwgcmVzdWx0KSB8fCByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGtleXMgPSB2aXNpdG9yS2V5c1tub2RlLnR5cGVdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2aXNpdEtleSh2aXNpdG9yLCBoYW5kbGVyIGFzIGFueSwgbm9kZSBhcyBhbnksIGtleXNbaV0pO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVyICYmIGhhbmRsZXJbJ2V4aXQnXSkge1xuICAgICAgcmVzdWx0ID0gaGFuZGxlclsnZXhpdCddLmNhbGwobnVsbCwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdmlzaXRLZXkoXG4gIHZpc2l0b3I6IE5vZGVWaXNpdG9yLFxuICBoYW5kbGVyOiBFbnRlckV4aXROb2RlSGFuZGxlcjxub2Rlcy5Ob2RlPixcbiAgbm9kZTogbm9kZXMuTm9kZSAmIFRyYXZlcnNlZE5vZGUsXG4gIGtleTogc3RyaW5nXG4pIHtcbiAgbGV0IHZhbHVlID0gbm9kZVtrZXldO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGtleUhhbmRsZXIgPSBoYW5kbGVyICYmIChoYW5kbGVyLmtleXNba2V5XSB8fCBoYW5kbGVyLmtleXMuQWxsKTtcbiAgbGV0IHJlc3VsdDtcblxuICBpZiAoa2V5SGFuZGxlciAmJiBrZXlIYW5kbGVyLmVudGVyKSB7XG4gICAgcmVzdWx0ID0ga2V5SGFuZGxlci5lbnRlci5jYWxsKG51bGwsIG5vZGUsIGtleSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBjYW5ub3RSZXBsYWNlT3JSZW1vdmVJbktleUhhbmRsZXJZZXQobm9kZSwga2V5KTtcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2aXNpdEFycmF5KHZpc2l0b3IsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzdWx0ID0gdmlzaXROb2RlKHZpc2l0b3IsIHZhbHVlKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFzc2lnbktleShub2RlLCBrZXksIHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleUhhbmRsZXIgJiYga2V5SGFuZGxlci5leGl0KSB7XG4gICAgcmVzdWx0ID0ga2V5SGFuZGxlci5leGl0LmNhbGwobnVsbCwgbm9kZSwga2V5KTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IGNhbm5vdFJlcGxhY2VPclJlbW92ZUluS2V5SGFuZGxlcllldChub2RlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2aXNpdEFycmF5KHZpc2l0b3I6IE5vZGVWaXNpdG9yLCBhcnJheTogbm9kZXMuTm9kZVtdKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcmVzdWx0ID0gdmlzaXROb2RlKHZpc2l0b3IsIGFycmF5W2ldKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGkgKz0gc3BsaWNlQXJyYXkoYXJyYXksIGksIHJlc3VsdCkgLSAxO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYXZlcnNlZE5vZGUge1xuICBba2V5OiBzdHJpbmddOiBub2Rlcy5Ob2RlO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25LZXkobm9kZTogVHJhdmVyc2VkTm9kZSAmIG5vZGVzLk5vZGUsIGtleTogc3RyaW5nLCByZXN1bHQ6IG5vZGVzLk5vZGUpIHtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIHRocm93IGNhbm5vdFJlbW92ZU5vZGUobm9kZVtrZXldLCBub2RlLCBrZXkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICBub2RlW2tleV0gPSByZXN1bHRbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IGNhbm5vdFJlbW92ZU5vZGUobm9kZVtrZXldLCBub2RlLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgY2Fubm90UmVwbGFjZU5vZGUobm9kZVtrZXldLCBub2RlLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlW2tleV0gPSByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsaWNlQXJyYXk8VD4oYXJyYXk6IFRbXSwgaW5kZXg6IG51bWJlciwgcmVzdWx0OiBUW10pIHtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxLCAuLi5yZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSwgcmVzdWx0KTtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmF2ZXJzZShub2RlOiBub2Rlcy5Ob2RlLCB2aXNpdG9yOiBOb2RlVmlzaXRvcikge1xuICB2aXNpdE5vZGUobm9ybWFsaXplVmlzaXRvcih2aXNpdG9yKSwgbm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVWaXNpdG9yKHZpc2l0b3I6IE5vZGVWaXNpdG9yKSB7XG4gIGxldCBub3JtYWxpemVkVmlzaXRvciA9IHt9O1xuXG4gIGZvciAobGV0IHR5cGUgaW4gdmlzaXRvcikge1xuICAgIGxldCBoYW5kbGVyID0gdmlzaXRvclt0eXBlXSB8fCB2aXNpdG9yLkFsbDtcbiAgICBsZXQgbm9ybWFsaXplZEtleXMgPSB7fTtcblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBrZXlzID0gaGFuZGxlci5rZXlzO1xuICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGtleXMpIHtcbiAgICAgICAgICBsZXQga2V5SGFuZGxlciA9IGtleXNba2V5XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleUhhbmRsZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkS2V5c1trZXldID0ge1xuICAgICAgICAgICAgICBlbnRlcjogdHlwZW9mIGtleUhhbmRsZXIuZW50ZXIgPT09ICdmdW5jdGlvbicgPyBrZXlIYW5kbGVyLmVudGVyIDogbnVsbCxcbiAgICAgICAgICAgICAgZXhpdDogdHlwZW9mIGtleUhhbmRsZXIuZXhpdCA9PT0gJ2Z1bmN0aW9uJyA/IGtleUhhbmRsZXIuZXhpdCA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleUhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRLZXlzW2tleV0gPSB7XG4gICAgICAgICAgICAgIGVudGVyOiBrZXlIYW5kbGVyLFxuICAgICAgICAgICAgICBleGl0OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9ybWFsaXplZFZpc2l0b3JbdHlwZV0gPSB7XG4gICAgICAgIGVudGVyOiB0eXBlb2YgaGFuZGxlci5lbnRlciA9PT0gJ2Z1bmN0aW9uJyA/IGhhbmRsZXIuZW50ZXIgOiBudWxsLFxuICAgICAgICBleGl0OiB0eXBlb2YgaGFuZGxlci5leGl0ID09PSAnZnVuY3Rpb24nID8gaGFuZGxlci5leGl0IDogbnVsbCxcbiAgICAgICAga2V5czogbm9ybWFsaXplZEtleXMsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5vcm1hbGl6ZWRWaXNpdG9yW3R5cGVdID0ge1xuICAgICAgICBlbnRlcjogaGFuZGxlcixcbiAgICAgICAgZXhpdDogbnVsbCxcbiAgICAgICAga2V5czogbm9ybWFsaXplZEtleXMsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkVmlzaXRvcjtcbn1cbiIsImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0ICogYXMgSEJTIGZyb20gJy4uL3R5cGVzL25vZGVzJztcbmltcG9ydCB7IHZvaWRNYXAgfSBmcm9tICcuLi9wYXJzZXIvdG9rZW5pemVyLWV2ZW50LWhhbmRsZXJzJztcblxuZnVuY3Rpb24gdW5yZWFjaGFibGUoKTogbmV2ZXIge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkKGFzdDogSEJTLk5vZGUpOiBzdHJpbmcge1xuICBpZiAoIWFzdCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBvdXRwdXQ6IHN0cmluZ1tdID0gW107XG5cbiAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgIGNhc2UgJ1Byb2dyYW0nOlxuICAgICAge1xuICAgICAgICBjb25zdCBjaGFpbkJsb2NrID0gYXN0WydjaGFpbmVkJ10gJiYgYXN0LmJvZHlbMF07XG4gICAgICAgIGlmIChjaGFpbkJsb2NrKSB7XG4gICAgICAgICAgY2hhaW5CbG9ja1snY2hhaW5lZCddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gYnVpbGRFYWNoKGFzdC5ib2R5KS5qb2luKCcnKTtcbiAgICAgICAgb3V0cHV0LnB1c2goYm9keSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdFbGVtZW50Tm9kZSc6XG4gICAgICBvdXRwdXQucHVzaCgnPCcsIGFzdC50YWcpO1xuICAgICAgaWYgKGFzdC5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICBvdXRwdXQucHVzaCgnICcsIGJ1aWxkRWFjaChhc3QuYXR0cmlidXRlcykuam9pbignICcpKTtcbiAgICAgIH1cbiAgICAgIGlmIChhc3QubW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICBvdXRwdXQucHVzaCgnICcsIGJ1aWxkRWFjaChhc3QubW9kaWZpZXJzKS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgaWYgKGFzdC5jb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJyAnLCBidWlsZEVhY2goYXN0LmNvbW1lbnRzKS5qb2luKCcgJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodm9pZE1hcFthc3QudGFnXSkge1xuICAgICAgICBpZiAoYXN0LnNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goJyAvJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQucHVzaCgnPicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJz4nKTtcbiAgICAgICAgb3V0cHV0LnB1c2guYXBwbHkob3V0cHV0LCBidWlsZEVhY2goYXN0LmNoaWxkcmVuKSk7XG4gICAgICAgIG91dHB1dC5wdXNoKCc8LycsIGFzdC50YWcsICc+Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBdHRyTm9kZSc6XG4gICAgICBvdXRwdXQucHVzaChhc3QubmFtZSwgJz0nKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYnVpbGQoYXN0LnZhbHVlKTtcbiAgICAgIGlmIChhc3QudmFsdWUudHlwZSA9PT0gJ1RleHROb2RlJykge1xuICAgICAgICBvdXRwdXQucHVzaCgnXCInLCB2YWx1ZSwgJ1wiJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdDb25jYXRTdGF0ZW1lbnQnOlxuICAgICAgb3V0cHV0LnB1c2goJ1wiJyk7XG4gICAgICBhc3QucGFydHMuZm9yRWFjaCgobm9kZTogYW55KSA9PiB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdTdHJpbmdMaXRlcmFsJykge1xuICAgICAgICAgIG91dHB1dC5wdXNoKG5vZGUub3JpZ2luYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5wdXNoKGJ1aWxkKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvdXRwdXQucHVzaCgnXCInKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1RleHROb2RlJzpcbiAgICAgIG91dHB1dC5wdXNoKGFzdC5jaGFycyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6XG4gICAgICB7XG4gICAgICAgIG91dHB1dC5wdXNoKGNvbXBhY3RKb2luKFsne3snLCBwYXRoUGFyYW1zKGFzdCksICd9fSddKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnOlxuICAgICAge1xuICAgICAgICBvdXRwdXQucHVzaChjb21wYWN0Sm9pbihbJ3t7IS0tJywgYXN0LnZhbHVlLCAnLS19fSddKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQnOlxuICAgICAge1xuICAgICAgICBvdXRwdXQucHVzaChjb21wYWN0Sm9pbihbJ3t7JywgcGF0aFBhcmFtcyhhc3QpLCAnfX0nXSkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUGF0aEV4cHJlc3Npb24nOlxuICAgICAgb3V0cHV0LnB1c2goYXN0Lm9yaWdpbmFsKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1N1YkV4cHJlc3Npb24nOlxuICAgICAge1xuICAgICAgICBvdXRwdXQucHVzaCgnKCcsIHBhdGhQYXJhbXMoYXN0KSwgJyknKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0Jvb2xlYW5MaXRlcmFsJzpcbiAgICAgIG91dHB1dC5wdXNoKGFzdC52YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAge1xuICAgICAgICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBpZiAoYXN0WydjaGFpbmVkJ10pIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKFsne3tlbHNlICcsIHBhdGhQYXJhbXMoYXN0KSwgJ319J10uam9pbignJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVzLnB1c2gob3BlbkJsb2NrKGFzdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMucHVzaChidWlsZChhc3QucHJvZ3JhbSkpO1xuXG4gICAgICAgIGlmIChhc3QuaW52ZXJzZSkge1xuICAgICAgICAgIGlmICghYXN0LmludmVyc2VbJ2NoYWluZWQnXSkge1xuICAgICAgICAgICAgbGluZXMucHVzaCgne3tlbHNlfX0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZXMucHVzaChidWlsZChhc3QuaW52ZXJzZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhc3RbJ2NoYWluZWQnXSkge1xuICAgICAgICAgIGxpbmVzLnB1c2goY2xvc2VCbG9jayhhc3QpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKGxpbmVzLmpvaW4oJycpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1BhcnRpYWxTdGF0ZW1lbnQnOlxuICAgICAge1xuICAgICAgICBvdXRwdXQucHVzaChjb21wYWN0Sm9pbihbJ3t7PicsIHBhdGhQYXJhbXMoYXN0KSwgJ319J10pKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0NvbW1lbnRTdGF0ZW1lbnQnOlxuICAgICAge1xuICAgICAgICBvdXRwdXQucHVzaChjb21wYWN0Sm9pbihbJzwhLS0nLCBhc3QudmFsdWUsICctLT4nXSkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU3RyaW5nTGl0ZXJhbCc6XG4gICAgICB7XG4gICAgICAgIG91dHB1dC5wdXNoKGBcIiR7YXN0LnZhbHVlfVwiYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdOdW1iZXJMaXRlcmFsJzpcbiAgICAgIHtcbiAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nKGFzdC52YWx1ZSkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnVW5kZWZpbmVkTGl0ZXJhbCc6XG4gICAgICB7XG4gICAgICAgIG91dHB1dC5wdXNoKCd1bmRlZmluZWQnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ051bGxMaXRlcmFsJzpcbiAgICAgIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJ251bGwnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0hhc2gnOlxuICAgICAge1xuICAgICAgICBvdXRwdXQucHVzaChcbiAgICAgICAgICBhc3QucGFpcnNcbiAgICAgICAgICAgIC5tYXAocGFpciA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBidWlsZChwYWlyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignICcpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdIYXNoUGFpcic6XG4gICAgICB7XG4gICAgICAgIG91dHB1dC5wdXNoKGAke2FzdC5rZXl9PSR7YnVpbGQoYXN0LnZhbHVlKX1gKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhY3QoYXJyYXk6IE9wdGlvbjxzdHJpbmc+W10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IG5ld0FycmF5OiBhbnlbXSA9IFtdO1xuICBhcnJheS5mb3JFYWNoKGEgPT4ge1xuICAgIGlmICh0eXBlb2YgYSAhPT0gJ3VuZGVmaW5lZCcgJiYgYSAhPT0gbnVsbCAmJiBhICE9PSAnJykge1xuICAgICAgbmV3QXJyYXkucHVzaChhKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRWFjaChhc3RzOiBIQlMuTm9kZVtdKTogc3RyaW5nW10ge1xuICByZXR1cm4gYXN0cy5tYXAoYnVpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXRoUGFyYW1zKGFzdDogSEJTLk5vZGUpOiBzdHJpbmcge1xuICBsZXQgcGF0aDogc3RyaW5nO1xuXG4gIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6XG4gICAgY2FzZSAnU3ViRXhwcmVzc2lvbic6XG4gICAgY2FzZSAnRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50JzpcbiAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICBpZiAoSEJTLmlzTGl0ZXJhbChhc3QucGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhc3QucGF0aC52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHBhdGggPSBidWlsZChhc3QucGF0aCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdQYXJ0aWFsU3RhdGVtZW50JzpcbiAgICAgIHBhdGggPSBidWlsZChhc3QubmFtZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVucmVhY2hhYmxlKCk7XG4gIH1cblxuICByZXR1cm4gY29tcGFjdEpvaW4oW3BhdGgsIGJ1aWxkRWFjaChhc3QucGFyYW1zKS5qb2luKCcgJyksIGJ1aWxkKGFzdC5oYXNoKV0sICcgJyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhY3RKb2luKGFycmF5OiBPcHRpb248c3RyaW5nPltdLCBkZWxpbWl0ZXI/OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gY29tcGFjdChhcnJheSkuam9pbihkZWxpbWl0ZXIgfHwgJycpO1xufVxuXG5mdW5jdGlvbiBibG9ja1BhcmFtcyhibG9jazogSEJTLkJsb2NrU3RhdGVtZW50KTogT3B0aW9uPHN0cmluZz4ge1xuICBjb25zdCBwYXJhbXMgPSBibG9jay5wcm9ncmFtLmJsb2NrUGFyYW1zO1xuICBpZiAocGFyYW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBgIGFzIHwke3BhcmFtcy5qb2luKCcgJyl9fGA7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gb3BlbkJsb2NrKGJsb2NrOiBIQlMuQmxvY2tTdGF0ZW1lbnQpOiBzdHJpbmcge1xuICByZXR1cm4gWyd7eyMnLCBwYXRoUGFyYW1zKGJsb2NrKSwgYmxvY2tQYXJhbXMoYmxvY2spLCAnfX0nXS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gY2xvc2VCbG9jayhibG9jazogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIFsne3svJywgYnVpbGQoYmxvY2sucGF0aCksICd9fSddLmpvaW4oJycpO1xufVxuIiwiaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuXG5leHBvcnQgdHlwZSBOb2RlQ2FsbGJhY2s8TiBleHRlbmRzIEFTVC5Ob2RlPiA9IChub2RlOiBOLCB3YWxrZXI6IFdhbGtlcikgPT4gdm9pZDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2Fsa2VyIHtcbiAgcHVibGljIHN0YWNrOiBhbnlbXSA9IFtdO1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgb3JkZXI/OiBhbnkpIHt9XG5cbiAgdmlzaXQ8TiBleHRlbmRzIEFTVC5Ob2RlPihub2RlOiBPcHRpb248Tj4sIGNhbGxiYWNrOiBOb2RlQ2FsbGJhY2s8Tj4pIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XG5cbiAgICBpZiAodGhpcy5vcmRlciA9PT0gJ3Bvc3QnKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuKG5vZGUsIGNhbGxiYWNrKTtcbiAgICAgIGNhbGxiYWNrKG5vZGUsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhub2RlLCB0aGlzKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4obm9kZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gIH1cblxuICBjaGlsZHJlbihub2RlOiBhbnksIGNhbGxiYWNrOiBhbnkpIHtcbiAgICBsZXQgdmlzaXRvciA9IHZpc2l0b3JzW25vZGUudHlwZV07XG4gICAgaWYgKHZpc2l0b3IpIHtcbiAgICAgIHZpc2l0b3IodGhpcywgbm9kZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgdmlzaXRvcnMgPSB7XG4gIFByb2dyYW0od2Fsa2VyOiBXYWxrZXIsIG5vZGU6IEFTVC5Qcm9ncmFtLCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPEFTVC5Ob2RlPikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB3YWxrZXIudmlzaXQobm9kZS5ib2R5W2ldLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIEVsZW1lbnROb2RlKHdhbGtlcjogV2Fsa2VyLCBub2RlOiBBU1QuRWxlbWVudE5vZGUsIGNhbGxiYWNrOiBOb2RlQ2FsbGJhY2s8QVNULk5vZGU+KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3YWxrZXIudmlzaXQobm9kZS5jaGlsZHJlbltpXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICBCbG9ja1N0YXRlbWVudCh3YWxrZXI6IFdhbGtlciwgbm9kZTogQVNULkJsb2NrU3RhdGVtZW50LCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPEFTVC5Qcm9ncmFtPikge1xuICAgIHdhbGtlci52aXNpdChub2RlLnByb2dyYW0sIGNhbGxiYWNrKTtcbiAgICB3YWxrZXIudmlzaXQobm9kZS5pbnZlcnNlIHx8IG51bGwsIGNhbGxiYWNrKTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgYiwgeyBTWU5USEVUSUMgfSBmcm9tICcuLi9idWlsZGVycyc7XG5pbXBvcnQgeyBhcHBlbmRDaGlsZCwgcGFyc2VFbGVtZW50QmxvY2tQYXJhbXMgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBIYW5kbGViYXJzTm9kZVZpc2l0b3JzIH0gZnJvbSAnLi9oYW5kbGViYXJzLW5vZGUtdmlzaXRvcnMnO1xuaW1wb3J0ICogYXMgQVNUIGZyb20gJy4uL3R5cGVzL25vZGVzJztcbmltcG9ydCBTeW50YXhFcnJvciBmcm9tICcuLi9lcnJvcnMvc3ludGF4LWVycm9yJztcbmltcG9ydCB7IFRhZyB9IGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQgYnVpbGRlcnMgZnJvbSAnLi4vYnVpbGRlcnMnO1xuaW1wb3J0IHRyYXZlcnNlLCB7IE5vZGVWaXNpdG9yIH0gZnJvbSAnLi4vdHJhdmVyc2FsL3RyYXZlcnNlJztcbmltcG9ydCBwcmludCBmcm9tICcuLi9nZW5lcmF0aW9uL3ByaW50JztcbmltcG9ydCBXYWxrZXIgZnJvbSAnLi4vdHJhdmVyc2FsL3dhbGtlcic7XG5pbXBvcnQgKiBhcyBoYW5kbGViYXJzIGZyb20gJ2hhbmRsZWJhcnMnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCBjb25zdCB2b2lkTWFwOiB7XG4gIFt0YWdOYW1lOiBzdHJpbmddOiBib29sZWFuO1xufSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmxldCB2b2lkVGFnTmFtZXMgPVxuICAnYXJlYSBiYXNlIGJyIGNvbCBjb21tYW5kIGVtYmVkIGhyIGltZyBpbnB1dCBrZXlnZW4gbGluayBtZXRhIHBhcmFtIHNvdXJjZSB0cmFjayB3YnInO1xudm9pZFRhZ05hbWVzLnNwbGl0KCcgJykuZm9yRWFjaCh0YWdOYW1lID0+IHtcbiAgdm9pZE1hcFt0YWdOYW1lXSA9IHRydWU7XG59KTtcblxuZXhwb3J0IGNsYXNzIFRva2VuaXplckV2ZW50SGFuZGxlcnMgZXh0ZW5kcyBIYW5kbGViYXJzTm9kZVZpc2l0b3JzIHtcbiAgcHJpdmF0ZSB0YWdPcGVuTGluZSA9IDA7XG4gIHByaXZhdGUgdGFnT3BlbkNvbHVtbiA9IDA7XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gIH1cblxuICAvLyBDb21tZW50XG5cbiAgYmVnaW5Db21tZW50KCkge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBiLmNvbW1lbnQoJycpO1xuICAgIHRoaXMuY3VycmVudE5vZGUubG9jID0ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgc3RhcnQ6IGIucG9zKHRoaXMudGFnT3BlbkxpbmUsIHRoaXMudGFnT3BlbkNvbHVtbiksXG4gICAgICBlbmQ6IChudWxsIGFzIGFueSkgYXMgQVNULlBvc2l0aW9uLFxuICAgIH07XG4gIH1cblxuICBhcHBlbmRUb0NvbW1lbnREYXRhKGNoYXI6IHN0cmluZykge1xuICAgIHRoaXMuY3VycmVudENvbW1lbnQudmFsdWUgKz0gY2hhcjtcbiAgfVxuXG4gIGZpbmlzaENvbW1lbnQoKSB7XG4gICAgdGhpcy5jdXJyZW50Q29tbWVudC5sb2MuZW5kID0gYi5wb3ModGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uKTtcblxuICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgdGhpcy5jdXJyZW50Q29tbWVudCk7XG4gIH1cblxuICAvLyBEYXRhXG5cbiAgYmVnaW5EYXRhKCkge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBiLnRleHQoKTtcbiAgICB0aGlzLmN1cnJlbnROb2RlLmxvYyA9IHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIHN0YXJ0OiBiLnBvcyh0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW4pLFxuICAgICAgZW5kOiAobnVsbCBhcyBhbnkpIGFzIEFTVC5Qb3NpdGlvbixcbiAgICB9O1xuICB9XG5cbiAgYXBwZW5kVG9EYXRhKGNoYXI6IHN0cmluZykge1xuICAgIHRoaXMuY3VycmVudERhdGEuY2hhcnMgKz0gY2hhcjtcbiAgfVxuXG4gIGZpbmlzaERhdGEoKSB7XG4gICAgdGhpcy5jdXJyZW50RGF0YS5sb2MuZW5kID0gYi5wb3ModGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uKTtcblxuICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgdGhpcy5jdXJyZW50RGF0YSk7XG4gIH1cblxuICAvLyBUYWdzIC0gYmFzaWNcblxuICB0YWdPcGVuKCkge1xuICAgIHRoaXMudGFnT3BlbkxpbmUgPSB0aGlzLnRva2VuaXplci5saW5lO1xuICAgIHRoaXMudGFnT3BlbkNvbHVtbiA9IHRoaXMudG9rZW5pemVyLmNvbHVtbjtcbiAgfVxuXG4gIGJlZ2luU3RhcnRUYWcoKSB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IHtcbiAgICAgIHR5cGU6ICdTdGFydFRhZycsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgIGNvbW1lbnRzOiBbXSxcbiAgICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICAgIGxvYzogU1lOVEhFVElDLFxuICAgIH07XG4gIH1cblxuICBiZWdpbkVuZFRhZygpIHtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0ge1xuICAgICAgdHlwZTogJ0VuZFRhZycsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgIGNvbW1lbnRzOiBbXSxcbiAgICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICAgIGxvYzogU1lOVEhFVElDLFxuICAgIH07XG4gIH1cblxuICBmaW5pc2hUYWcoKSB7XG4gICAgbGV0IHsgbGluZSwgY29sdW1uIH0gPSB0aGlzLnRva2VuaXplcjtcblxuICAgIGxldCB0YWcgPSB0aGlzLmN1cnJlbnRUYWc7XG4gICAgdGFnLmxvYyA9IGIubG9jKHRoaXMudGFnT3BlbkxpbmUsIHRoaXMudGFnT3BlbkNvbHVtbiwgbGluZSwgY29sdW1uKTtcblxuICAgIGlmICh0YWcudHlwZSA9PT0gJ1N0YXJ0VGFnJykge1xuICAgICAgdGhpcy5maW5pc2hTdGFydFRhZygpO1xuXG4gICAgICBpZiAodm9pZE1hcFt0YWcubmFtZV0gfHwgdGFnLnNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHRoaXMuZmluaXNoRW5kVGFnKHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFnLnR5cGUgPT09ICdFbmRUYWcnKSB7XG4gICAgICB0aGlzLmZpbmlzaEVuZFRhZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoU3RhcnRUYWcoKSB7XG4gICAgbGV0IHsgbmFtZSwgYXR0cmlidXRlcywgbW9kaWZpZXJzLCBjb21tZW50cywgc2VsZkNsb3NpbmcgfSA9IHRoaXMuY3VycmVudFN0YXJ0VGFnO1xuICAgIGxldCBsb2MgPSBiLmxvYyh0aGlzLnRhZ09wZW5MaW5lLCB0aGlzLnRhZ09wZW5Db2x1bW4pO1xuICAgIGxldCBlbGVtZW50ID0gYi5lbGVtZW50KHsgbmFtZSwgc2VsZkNsb3NpbmcgfSwgYXR0cmlidXRlcywgbW9kaWZpZXJzLCBbXSwgY29tbWVudHMsIGxvYyk7XG4gICAgdGhpcy5lbGVtZW50U3RhY2sucHVzaChlbGVtZW50KTtcbiAgfVxuXG4gIGZpbmlzaEVuZFRhZyhpc1ZvaWQ6IGJvb2xlYW4pIHtcbiAgICBsZXQgdGFnID0gdGhpcy5jdXJyZW50VGFnO1xuXG4gICAgbGV0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKSBhcyBBU1QuRWxlbWVudE5vZGU7XG4gICAgbGV0IHBhcmVudCA9IHRoaXMuY3VycmVudEVsZW1lbnQoKTtcblxuICAgIHZhbGlkYXRlRW5kVGFnKHRhZywgZWxlbWVudCwgaXNWb2lkKTtcblxuICAgIGVsZW1lbnQubG9jLmVuZC5saW5lID0gdGhpcy50b2tlbml6ZXIubGluZTtcbiAgICBlbGVtZW50LmxvYy5lbmQuY29sdW1uID0gdGhpcy50b2tlbml6ZXIuY29sdW1uO1xuXG4gICAgcGFyc2VFbGVtZW50QmxvY2tQYXJhbXMoZWxlbWVudCk7XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50LCBlbGVtZW50KTtcbiAgfVxuXG4gIG1hcmtUYWdBc1NlbGZDbG9zaW5nKCkge1xuICAgIHRoaXMuY3VycmVudFRhZy5zZWxmQ2xvc2luZyA9IHRydWU7XG4gIH1cblxuICAvLyBUYWdzIC0gbmFtZVxuXG4gIGFwcGVuZFRvVGFnTmFtZShjaGFyOiBzdHJpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnRUYWcubmFtZSArPSBjaGFyO1xuICB9XG5cbiAgLy8gVGFncyAtIGF0dHJpYnV0ZXNcblxuICBiZWdpbkF0dHJpYnV0ZSgpIHtcbiAgICBsZXQgdGFnID0gdGhpcy5jdXJyZW50VGFnO1xuICAgIGlmICh0YWcudHlwZSA9PT0gJ0VuZFRhZycpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgYEludmFsaWQgZW5kIHRhZzogY2xvc2luZyB0YWcgbXVzdCBub3QgaGF2ZSBhdHRyaWJ1dGVzLCBgICtcbiAgICAgICAgICBgaW4gXFxgJHt0YWcubmFtZX1cXGAgKG9uIGxpbmUgJHt0aGlzLnRva2VuaXplci5saW5lfSkuYCxcbiAgICAgICAgdGFnLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGUgPSB7XG4gICAgICBuYW1lOiAnJyxcbiAgICAgIHBhcnRzOiBbXSxcbiAgICAgIGlzUXVvdGVkOiBmYWxzZSxcbiAgICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgICBzdGFydDogYi5wb3ModGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uKSxcbiAgICAgIHZhbHVlU3RhcnRMaW5lOiAwLFxuICAgICAgdmFsdWVTdGFydENvbHVtbjogMCxcbiAgICB9O1xuICB9XG5cbiAgYXBwZW5kVG9BdHRyaWJ1dGVOYW1lKGNoYXI6IHN0cmluZykge1xuICAgIHRoaXMuY3VycmVudEF0dHIubmFtZSArPSBjaGFyO1xuICB9XG5cbiAgYmVnaW5BdHRyaWJ1dGVWYWx1ZShpc1F1b3RlZDogYm9vbGVhbikge1xuICAgIHRoaXMuY3VycmVudEF0dHIuaXNRdW90ZWQgPSBpc1F1b3RlZDtcbiAgICB0aGlzLmN1cnJlbnRBdHRyLnZhbHVlU3RhcnRMaW5lID0gdGhpcy50b2tlbml6ZXIubGluZTtcbiAgICB0aGlzLmN1cnJlbnRBdHRyLnZhbHVlU3RhcnRDb2x1bW4gPSB0aGlzLnRva2VuaXplci5jb2x1bW47XG4gIH1cblxuICBhcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKGNoYXI6IHN0cmluZykge1xuICAgIGxldCBwYXJ0cyA9IHRoaXMuY3VycmVudEF0dHIucGFydHM7XG4gICAgbGV0IGxhc3RQYXJ0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAobGFzdFBhcnQgJiYgbGFzdFBhcnQudHlwZSA9PT0gJ1RleHROb2RlJykge1xuICAgICAgbGFzdFBhcnQuY2hhcnMgKz0gY2hhcjtcblxuICAgICAgLy8gdXBkYXRlIGVuZCBsb2NhdGlvbiBmb3IgZWFjaCBhZGRlZCBjaGFyXG4gICAgICBsYXN0UGFydC5sb2MuZW5kLmxpbmUgPSB0aGlzLnRva2VuaXplci5saW5lO1xuICAgICAgbGFzdFBhcnQubG9jLmVuZC5jb2x1bW4gPSB0aGlzLnRva2VuaXplci5jb2x1bW47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluaXRpYWxseSBhc3N1bWUgdGhlIHRleHQgbm9kZSBpcyBhIHNpbmdsZSBjaGFyXG4gICAgICBsZXQgbG9jID0gYi5sb2MoXG4gICAgICAgIHRoaXMudG9rZW5pemVyLmxpbmUsXG4gICAgICAgIHRoaXMudG9rZW5pemVyLmNvbHVtbixcbiAgICAgICAgdGhpcy50b2tlbml6ZXIubGluZSxcbiAgICAgICAgdGhpcy50b2tlbml6ZXIuY29sdW1uXG4gICAgICApO1xuXG4gICAgICAvLyBjb3JyZWN0IGZvciBgXFxuYCBhcyBmaXJzdCBjaGFyXG4gICAgICBpZiAoY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgbG9jLnN0YXJ0LmxpbmUgLT0gMTtcbiAgICAgICAgbG9jLnN0YXJ0LmNvbHVtbiA9IGxhc3RQYXJ0ID8gbGFzdFBhcnQubG9jLmVuZC5jb2x1bW4gOiB0aGlzLmN1cnJlbnRBdHRyLnZhbHVlU3RhcnRDb2x1bW47XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXh0ID0gYi50ZXh0KGNoYXIsIGxvYyk7XG4gICAgICBwYXJ0cy5wdXNoKHRleHQpO1xuICAgIH1cbiAgfVxuXG4gIGZpbmlzaEF0dHJpYnV0ZVZhbHVlKCkge1xuICAgIGxldCB7IG5hbWUsIHBhcnRzLCBpc1F1b3RlZCwgaXNEeW5hbWljLCB2YWx1ZVN0YXJ0TGluZSwgdmFsdWVTdGFydENvbHVtbiB9ID0gdGhpcy5jdXJyZW50QXR0cjtcbiAgICBsZXQgdmFsdWUgPSBhc3NlbWJsZUF0dHJpYnV0ZVZhbHVlKHBhcnRzLCBpc1F1b3RlZCwgaXNEeW5hbWljLCB0aGlzLnRva2VuaXplci5saW5lKTtcbiAgICB2YWx1ZS5sb2MgPSBiLmxvYyh2YWx1ZVN0YXJ0TGluZSwgdmFsdWVTdGFydENvbHVtbiwgdGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uKTtcblxuICAgIGxldCBsb2MgPSBiLmxvYyhcbiAgICAgIHRoaXMuY3VycmVudEF0dHIuc3RhcnQubGluZSxcbiAgICAgIHRoaXMuY3VycmVudEF0dHIuc3RhcnQuY29sdW1uLFxuICAgICAgdGhpcy50b2tlbml6ZXIubGluZSxcbiAgICAgIHRoaXMudG9rZW5pemVyLmNvbHVtblxuICAgICk7XG5cbiAgICBsZXQgYXR0cmlidXRlID0gYi5hdHRyKG5hbWUsIHZhbHVlLCBsb2MpO1xuXG4gICAgdGhpcy5jdXJyZW50U3RhcnRUYWcuYXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XG4gIH1cblxuICByZXBvcnRTeW50YXhFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgU3ludGF4IGVycm9yIGF0IGxpbmUgJHt0aGlzLnRva2VuaXplci5saW5lfSBjb2wgJHt0aGlzLnRva2VuaXplci5jb2x1bW59OiAke21lc3NhZ2V9YCxcbiAgICAgIGIubG9jKHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtbilcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VtYmxlQXR0cmlidXRlVmFsdWUoXG4gIHBhcnRzOiAoQVNULk11c3RhY2hlU3RhdGVtZW50IHwgQVNULlRleHROb2RlKVtdLFxuICBpc1F1b3RlZDogYm9vbGVhbixcbiAgaXNEeW5hbWljOiBib29sZWFuLFxuICBsaW5lOiBudW1iZXJcbikge1xuICBpZiAoaXNEeW5hbWljKSB7XG4gICAgaWYgKGlzUXVvdGVkKSB7XG4gICAgICByZXR1cm4gYXNzZW1ibGVDb25jYXRlbmF0ZWRWYWx1ZShwYXJ0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcbiAgICAgICAgcGFydHMubGVuZ3RoID09PSAxIHx8XG4gICAgICAgIChwYXJ0cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICBwYXJ0c1sxXS50eXBlID09PSAnVGV4dE5vZGUnICYmXG4gICAgICAgICAgKHBhcnRzWzFdIGFzIEFTVC5UZXh0Tm9kZSkuY2hhcnMgPT09ICcvJylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYEFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgbXVzdGFjaGUsIGAgK1xuICAgICAgICAgICAgYHByZWNlZWRlZCBieSB3aGl0ZXNwYWNlIG9yIGEgJz0nIGNoYXJhY3RlciwgYW5kIGAgK1xuICAgICAgICAgICAgYGZvbGxvd2VkIGJ5IHdoaXRlc3BhY2UsIGEgJz4nIGNoYXJhY3Rlciwgb3IgJy8+JyAob24gbGluZSAke2xpbmV9KWAsXG4gICAgICAgICAgYi5sb2MobGluZSwgMClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6IGIudGV4dCgnJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZW1ibGVDb25jYXRlbmF0ZWRWYWx1ZShwYXJ0czogKEFTVC5NdXN0YWNoZVN0YXRlbWVudCB8IEFTVC5UZXh0Tm9kZSlbXSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhcnQ6IEFTVC5CYXNlTm9kZSA9IHBhcnRzW2ldO1xuXG4gICAgaWYgKHBhcnQudHlwZSAhPT0gJ011c3RhY2hlU3RhdGVtZW50JyAmJiBwYXJ0LnR5cGUgIT09ICdUZXh0Tm9kZScpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIG5vZGUgaW4gcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZTogJyArIHBhcnRbJ3R5cGUnXSxcbiAgICAgICAgcGFydC5sb2NcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGIuY29uY2F0KHBhcnRzKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFbmRUYWcoXG4gIHRhZzogVGFnPCdTdGFydFRhZycgfCAnRW5kVGFnJz4sXG4gIGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSxcbiAgc2VsZkNsb3Npbmc6IGJvb2xlYW5cbikge1xuICBsZXQgZXJyb3I7XG5cbiAgaWYgKHZvaWRNYXBbdGFnLm5hbWVdICYmICFzZWxmQ2xvc2luZykge1xuICAgIC8vIEVuZ1RhZyBpcyBhbHNvIGNhbGxlZCBieSBTdGFydFRhZyBmb3Igdm9pZCBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MgKGkuZS5cbiAgICAvLyA8aW5wdXQ+IG9yIDxiciAvPiwgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgdGhhdCBoZXJlLiBPdGhlcndpc2UsIHdlIHdvdWxkXG4gICAgLy8gdGhyb3cgYW4gZXJyb3IgZm9yIHRob3NlIGNhc2VzLlxuICAgIGVycm9yID0gJ0ludmFsaWQgZW5kIHRhZyAnICsgZm9ybWF0RW5kVGFnSW5mbyh0YWcpICsgJyAodm9pZCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBlbmQgdGFncykuJztcbiAgfSBlbHNlIGlmIChlbGVtZW50LnRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXJyb3IgPSAnQ2xvc2luZyB0YWcgJyArIGZvcm1hdEVuZFRhZ0luZm8odGFnKSArICcgd2l0aG91dCBhbiBvcGVuIHRhZy4nO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQudGFnICE9PSB0YWcubmFtZSkge1xuICAgIGVycm9yID1cbiAgICAgICdDbG9zaW5nIHRhZyAnICtcbiAgICAgIGZvcm1hdEVuZFRhZ0luZm8odGFnKSArXG4gICAgICAnIGRpZCBub3QgbWF0Y2ggbGFzdCBvcGVuIHRhZyBgJyArXG4gICAgICBlbGVtZW50LnRhZyArXG4gICAgICAnYCAob24gbGluZSAnICtcbiAgICAgIGVsZW1lbnQubG9jLnN0YXJ0LmxpbmUgK1xuICAgICAgJykuJztcbiAgfVxuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihlcnJvciwgZWxlbWVudC5sb2MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEVuZFRhZ0luZm8odGFnOiBUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPikge1xuICByZXR1cm4gJ2AnICsgdGFnLm5hbWUgKyAnYCAob24gbGluZSAnICsgdGFnLmxvYy5lbmQubGluZSArICcpJztcbn1cblxuLyoqXG4gIEFTVFBsdWdpbnMgY2FuIG1ha2UgY2hhbmdlcyB0byB0aGUgR2xpbW1lciB0ZW1wbGF0ZSBBU1QgYmVmb3JlXG4gIGNvbXBpbGF0aW9uIGJlZ2lucy5cbiovXG5leHBvcnQgaW50ZXJmYWNlIEFTVFBsdWdpbkJ1aWxkZXIge1xuICAoZW52OiBBU1RQbHVnaW5FbnZpcm9ubWVudCk6IEFTVFBsdWdpbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBU1RQbHVnaW4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHZpc2l0b3I6IE5vZGVWaXNpdG9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFTVFBsdWdpbkVudmlyb25tZW50IHtcbiAgbWV0YT86IGFueTtcbiAgc3ludGF4OiBTeW50YXg7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlcHJvY2Vzc09wdGlvbnMge1xuICBwbHVnaW5zPzoge1xuICAgIGFzdD86IEFTVFBsdWdpbkJ1aWxkZXJbXTtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeW50YXgge1xuICBwYXJzZTogdHlwZW9mIHByZXByb2Nlc3M7XG4gIGJ1aWxkZXJzOiB0eXBlb2YgYnVpbGRlcnM7XG4gIHByaW50OiB0eXBlb2YgcHJpbnQ7XG4gIHRyYXZlcnNlOiB0eXBlb2YgdHJhdmVyc2U7XG4gIFdhbGtlcjogdHlwZW9mIFdhbGtlcjtcbn1cblxuY29uc3Qgc3ludGF4OiBTeW50YXggPSB7XG4gIHBhcnNlOiBwcmVwcm9jZXNzLFxuICBidWlsZGVycyxcbiAgcHJpbnQsXG4gIHRyYXZlcnNlLFxuICBXYWxrZXIsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2VzcyhodG1sOiBzdHJpbmcsIG9wdGlvbnM/OiBQcmVwcm9jZXNzT3B0aW9ucyk6IEFTVC5Qcm9ncmFtIHtcbiAgbGV0IGFzdCA9IHR5cGVvZiBodG1sID09PSAnb2JqZWN0JyA/IGh0bWwgOiBoYW5kbGViYXJzLnBhcnNlKGh0bWwpO1xuICBsZXQgcHJvZ3JhbSA9IG5ldyBUb2tlbml6ZXJFdmVudEhhbmRsZXJzKGh0bWwpLmFjY2VwdE5vZGUoYXN0KTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBsdWdpbnMgJiYgb3B0aW9ucy5wbHVnaW5zLmFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3B0aW9ucy5wbHVnaW5zLmFzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxldCB0cmFuc2Zvcm0gPSBvcHRpb25zLnBsdWdpbnMuYXN0W2ldO1xuICAgICAgbGV0IGVudiA9IGFzc2lnbih7fSwgb3B0aW9ucywgeyBzeW50YXggfSwgeyBwbHVnaW5zOiB1bmRlZmluZWQgfSk7XG5cbiAgICAgIGxldCBwbHVnaW5SZXN1bHQgPSB0cmFuc2Zvcm0oZW52KTtcblxuICAgICAgdHJhdmVyc2UocHJvZ3JhbSwgcGx1Z2luUmVzdWx0LnZpc2l0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9ncmFtO1xufVxuIiwiLy8gdXNlZCBieSBlbWJlci1jb21waWxlclxuZXhwb3J0IHtcbiAgcHJlcHJvY2VzcyxcbiAgUHJlcHJvY2Vzc09wdGlvbnMsXG4gIEFTVFBsdWdpbixcbiAgQVNUUGx1Z2luQnVpbGRlcixcbiAgQVNUUGx1Z2luRW52aXJvbm1lbnQsXG4gIFN5bnRheCxcbn0gZnJvbSAnLi9saWIvcGFyc2VyL3Rva2VuaXplci1ldmVudC1oYW5kbGVycyc7XG5cbi8vIG5lZWRlZCBmb3IgdGVzdHMgb25seVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBidWlsZGVycyB9IGZyb20gJy4vbGliL2J1aWxkZXJzJztcbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgVHJhdmVyc2FsRXJyb3IsXG4gIGNhbm5vdFJlbW92ZU5vZGUsXG4gIGNhbm5vdFJlcGxhY2VOb2RlLFxuICBjYW5ub3RSZXBsYWNlT3JSZW1vdmVJbktleUhhbmRsZXJZZXQsXG59IGZyb20gJy4vbGliL3RyYXZlcnNhbC9lcnJvcnMnO1xuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB0cmF2ZXJzZSxcbiAgTm9kZUhhbmRsZXIsXG4gIE5vZGVWaXNpdG9yLFxuICBOb2RlSGFuZGxlckZ1bmN0aW9uLFxuICBFbnRlckV4aXROb2RlSGFuZGxlcixcbn0gZnJvbSAnLi9saWIvdHJhdmVyc2FsL3RyYXZlcnNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgV2Fsa2VyIH0gZnJvbSAnLi9saWIvdHJhdmVyc2FsL3dhbGtlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByaW50IH0gZnJvbSAnLi9saWIvZ2VuZXJhdGlvbi9wcmludCc7XG5cbi8vIGVycm9yc1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTeW50YXhFcnJvciB9IGZyb20gJy4vbGliL2Vycm9ycy9zeW50YXgtZXJyb3InO1xuXG4vLyBBU1RcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuL2xpYi90eXBlcy9ub2Rlcyc7XG5leHBvcnQgeyBBU1QgfTtcbmV4cG9ydCB7IGlzTGl0ZXJhbCwgcHJpbnRMaXRlcmFsIH0gZnJvbSAnLi9saWIvdXRpbHMnO1xuIl0sIm5hbWVzIjpbIkFTVC5pc0xpdGVyYWwiLCJFbnRpdHlQYXJzZXIiLCJuYW1lZENoYXJSZWZzIiwiRXZlbnRlZFRva2VuaXplciIsImlzTGl0ZXJhbCIsIkhCUy5pc0xpdGVyYWwiLCJoYW5kbGViYXJzLnBhcnNlIiwiYXNzaWduIl0sIm1hcHBpbmdzIjoiOztnQkE4RXVCLE1BQ3JCO1dBQ0UsS0FBSyxTQUFTLG1CQUNiLEtBQUssU0FBUyx1QkFBdUIsS0FBSyxLQUFLLFNBQVM7O0FBK0Y3RCxtQkFBMEIsT0FDeEI7V0FBTyxDQUFDLEVBQUUsT0FBTyxVQUFVLFlBQVksTUFBTSxLQUFLLE1BQU07Ozs7Ozs7OztBQ3pLMUQsdUJBQ0UsTUFDQSxRQUNBLE1BQ0EsS0FDQSxLQUVBO1FBQUksQ0FBQ0EsVUFBYyxPQUFPO2VBQ2pCLFVBQVU7OztjQUlYOztnQkFFRSxVQUFVO2NBQ1osUUFBUSxVQUFVO2lCQUNmLENBQUM7YUFDTCxTQUFTLE9BTlQ7OztBQVVULG9CQUNFLE1BQ0EsUUFDQSxNQUNBLFNBQ0EsU0FDQSxLQUVBOztjQUNRO2NBQ0EsVUFBVTtnQkFDUixVQUFVO2NBQ1osUUFBUSxVQUFVO2lCQUNmLFdBQVc7aUJBQ1gsV0FBVzthQUNmLFNBQVMsT0FQVDs7O0FBV1QsOEJBQ0UsTUFDQSxRQUNBLE1BQ0EsS0FFQTs7Y0FDUTtjQUNBLFVBQVU7Z0JBQ1IsVUFBVTtjQUNaLFFBQVEsVUFBVTthQUNuQixTQUFTLE9BTFQ7OztB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