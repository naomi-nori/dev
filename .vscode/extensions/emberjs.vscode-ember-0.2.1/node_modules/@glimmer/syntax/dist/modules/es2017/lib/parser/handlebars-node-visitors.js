import b from '../builders';
import { appendChild, isLiteral, printLiteral } from '../utils';
import { Parser } from '../parser';
import SyntaxError from '../errors/syntax-error';
export class HandlebarsNodeVisitors extends Parser {
    constructor() {
        super(...arguments);
        this.cursorCount = 0;
    }
    cursor() {
        return `%cursor:${this.cursorCount++}%`;
    }
    Program(program) {
        let body = [];
        this.cursorCount = 0;
        let node = b.program(body, program.blockParams, program.loc);
        let i,
            l = program.body.length;
        this.elementStack.push(node);
        if (l === 0) {
            return this.elementStack.pop();
        }
        for (i = 0; i < l; i++) {
            this.acceptNode(program.body[i]);
        }
        // Ensure that that the element stack is balanced properly.
        let poppedNode = this.elementStack.pop();
        if (poppedNode !== node) {
            let elementNode = poppedNode;
            throw new SyntaxError('Unclosed element `' + elementNode.tag + '` (on line ' + elementNode.loc.start.line + ').', elementNode.loc);
        }
        return node;
    }
    BlockStatement(block) {
        if (this.tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(block));
            return;
        }
        if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {
            throw new SyntaxError('A block may only be used inside an HTML element or another block.', block.loc);
        }
        let { path, params, hash } = acceptCallNodes(this, block);
        let program = this.Program(block.program);
        let inverse = block.inverse ? this.Program(block.inverse) : null;
        if (path.original === 'in-element') {
            hash = addInElementHash(this.cursor(), hash, block.loc);
        }
        let node = b.block(path, params, hash, program, inverse, block.loc);
        let parentProgram = this.currentElement();
        appendChild(parentProgram, node);
    }
    MustacheStatement(rawMustache) {
        let { tokenizer } = this;
        if (tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawMustache));
            return;
        }
        let mustache;
        let { escaped, loc } = rawMustache;
        if (rawMustache.path.type.match(/Literal$/)) {
            mustache = {
                type: 'MustacheStatement',
                path: this.acceptNode(rawMustache.path),
                params: [],
                hash: b.hash(),
                escaped,
                loc
            };
        } else {
            let { path, params, hash } = acceptCallNodes(this, rawMustache);
            mustache = b.mustache(path, params, hash, !escaped, loc);
        }
        switch (tokenizer.state) {
            // Tag helpers
            case "tagName" /* tagName */:
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            case "beforeAttributeName" /* beforeAttributeName */:
                addElementModifier(this.currentStartTag, mustache);
                break;
            case "attributeName" /* attributeName */:
            case "afterAttributeName" /* afterAttributeName */:
                this.beginAttributeValue(false);
                this.finishAttributeValue();
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            case "afterAttributeValueQuoted" /* afterAttributeValueQuoted */:
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            // Attribute values
            case "beforeAttributeValue" /* beforeAttributeValue */:
                this.beginAttributeValue(false);
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                tokenizer.transitionTo("attributeValueUnquoted" /* attributeValueUnquoted */);
                break;
            case "attributeValueDoubleQuoted" /* attributeValueDoubleQuoted */:
            case "attributeValueSingleQuoted" /* attributeValueSingleQuoted */:
            case "attributeValueUnquoted" /* attributeValueUnquoted */:
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                break;
            // TODO: Only append child when the tokenizer state makes
            // sense to do so, otherwise throw an error.
            default:
                appendChild(this.currentElement(), mustache);
        }
        return mustache;
    }
    ContentStatement(content) {
        updateTokenizerLocation(this.tokenizer, content);
        this.tokenizer.tokenizePart(content.value);
        this.tokenizer.flushData();
    }
    CommentStatement(rawComment) {
        let { tokenizer } = this;
        if (tokenizer.state === "comment" /* comment */) {
                this.appendToCommentData(this.sourceForNode(rawComment));
                return null;
            }
        let { value, loc } = rawComment;
        let comment = b.mustacheComment(value, loc);
        switch (tokenizer.state) {
            case "beforeAttributeName" /* beforeAttributeName */:
                this.currentStartTag.comments.push(comment);
                break;
            case "beforeData" /* beforeData */:
            case "data" /* data */:
                appendChild(this.currentElement(), comment);
                break;
            default:
                throw new SyntaxError(`Using a Handlebars comment when in the \`${tokenizer['state']}\` state is not supported: "${comment.value}" on line ${loc.start.line}:${loc.start.column}`, rawComment.loc);
        }
        return comment;
    }
    PartialStatement(partial) {
        let { loc } = partial;
        throw new SyntaxError(`Handlebars partials are not supported: "${this.sourceForNode(partial, partial.name)}" at L${loc.start.line}:C${loc.start.column}`, partial.loc);
    }
    PartialBlockStatement(partialBlock) {
        let { loc } = partialBlock;
        throw new SyntaxError(`Handlebars partial blocks are not supported: "${this.sourceForNode(partialBlock, partialBlock.name)}" at L${loc.start.line}:C${loc.start.column}`, partialBlock.loc);
    }
    Decorator(decorator) {
        let { loc } = decorator;
        throw new SyntaxError(`Handlebars decorators are not supported: "${this.sourceForNode(decorator, decorator.path)}" at L${loc.start.line}:C${loc.start.column}`, decorator.loc);
    }
    DecoratorBlock(decoratorBlock) {
        let { loc } = decoratorBlock;
        throw new SyntaxError(`Handlebars decorator blocks are not supported: "${this.sourceForNode(decoratorBlock, decoratorBlock.path)}" at L${loc.start.line}:C${loc.start.column}`, decoratorBlock.loc);
    }
    SubExpression(sexpr) {
        let { path, params, hash } = acceptCallNodes(this, sexpr);
        return b.sexpr(path, params, hash, sexpr.loc);
    }
    PathExpression(path) {
        let { original, loc } = path;
        let parts;
        if (original.indexOf('/') !== -1) {
            if (original.slice(0, 2) === './') {
                throw new SyntaxError(`Using "./" is not supported in Glimmer and unnecessary: "${path.original}" on line ${loc.start.line}.`, path.loc);
            }
            if (original.slice(0, 3) === '../') {
                throw new SyntaxError(`Changing context using "../" is not supported in Glimmer: "${path.original}" on line ${loc.start.line}.`, path.loc);
            }
            if (original.indexOf('.') !== -1) {
                throw new SyntaxError(`Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths: "${path.original}" on line ${loc.start.line}.`, path.loc);
            }
            parts = [path.parts.join('/')];
        } else {
            parts = path.parts;
        }
        let thisHead = false;
        // This is to fix a bug in the Handlebars AST where the path expressions in
        // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
        // are simply turned into `{{foo}}`. The fix is to push it back onto the
        // parts array and let the runtime see the difference. However, we cannot
        // simply use the string `this` as it means literally the property called
        // "this" in the current context (it can be expressed in the syntax as
        // `{{[this]}}`, where the square bracket are generally for this kind of
        // escaping â€“ such as `{{foo.["bar.baz"]}}` would mean lookup a property
        // named literally "bar.baz" on `this.foo`). By convention, we use `null`
        // for this purpose.
        if (original.match(/^this(\..+)?$/)) {
            thisHead = true;
        }
        return {
            type: 'PathExpression',
            original: path.original,
            this: thisHead,
            parts,
            data: path.data,
            loc: path.loc
        };
    }
    Hash(hash) {
        let pairs = [];
        for (let i = 0; i < hash.pairs.length; i++) {
            let pair = hash.pairs[i];
            pairs.push(b.pair(pair.key, this.acceptNode(pair.value), pair.loc));
        }
        return b.hash(pairs, hash.loc);
    }
    StringLiteral(string) {
        return b.literal('StringLiteral', string.value, string.loc);
    }
    BooleanLiteral(boolean) {
        return b.literal('BooleanLiteral', boolean.value, boolean.loc);
    }
    NumberLiteral(number) {
        return b.literal('NumberLiteral', number.value, number.loc);
    }
    UndefinedLiteral(undef) {
        return b.literal('UndefinedLiteral', undefined, undef.loc);
    }
    NullLiteral(nul) {
        return b.literal('NullLiteral', null, nul.loc);
    }
}
function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
        // if it is empty, just return the count of newlines
        // in original
        return {
            lines: original.split('\n').length - 1,
            columns: 0
        };
    }
    // otherwise, return the number of newlines prior to
    // `value`
    let difference = original.split(value)[0];
    let lines = difference.split(/\n/);
    let lineCount = lines.length - 1;
    return {
        lines: lineCount,
        columns: lines[lineCount].length
    };
}
function updateTokenizerLocation(tokenizer, content) {
    let line = content.loc.start.line;
    let column = content.loc.start.column;
    let offsets = calculateRightStrippedOffsets(content.original, content.value);
    line = line + offsets.lines;
    if (offsets.lines) {
        column = offsets.columns;
    } else {
        column = column + offsets.columns;
    }
    tokenizer.line = line;
    tokenizer.column = column;
}
function acceptCallNodes(compiler, node) {
    let path = compiler.PathExpression(node.path);
    let params = node.params ? node.params.map(e => compiler.acceptNode(e)) : [];
    let hash = node.hash ? compiler.Hash(node.hash) : b.hash();
    return { path, params, hash };
}
function addElementModifier(element, mustache) {
    let { path, params, hash, loc } = mustache;
    if (isLiteral(path)) {
        let modifier = `{{${printLiteral(path)}}}`;
        let tag = `<${element.name} ... ${modifier} ...`;
        throw new SyntaxError(`In ${tag}, ${modifier} is not a valid modifier: "${path.original}" on line ${loc && loc.start.line}.`, mustache.loc);
    }
    let modifier = b.elementModifier(path, params, hash, loc);
    element.modifiers.push(modifier);
}
function addInElementHash(cursor, hash, loc) {
    let hasNextSibling = false;
    hash.pairs.forEach(pair => {
        if (pair.key === 'guid') {
            throw new SyntaxError('Cannot pass `guid` from user space', loc);
        }
        if (pair.key === 'nextSibling') {
            hasNextSibling = true;
        }
    });
    let guid = b.literal('StringLiteral', cursor);
    let guidPair = b.pair('guid', guid);
    hash.pairs.unshift(guidPair);
    if (!hasNextSibling) {
        let nullLiteral = b.literal('NullLiteral', null);
        let nextSibling = b.pair('nextSibling', nullLiteral);
        hash.pairs.push(nextSibling);
    }
    return hash;
}
function appendDynamicAttributeValuePart(attribute, part) {
    attribute.isDynamic = true;
    attribute.parts.push(part);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9wYXJzZXIvaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sQUFBQyxPQUFNLEFBQWEsQUFBQztBQUM1QixBQUFPLFNBQUUsQUFBVyxhQUFFLEFBQVMsV0FBRSxBQUFZLEFBQUUsb0JBQU0sQUFBVSxBQUFDO0FBR2hFLEFBQU8sU0FBRSxBQUFNLEFBQWtCLGNBQU0sQUFBVyxBQUFDO0FBQ25ELE9BQU8sQUFBVyxpQkFBTSxBQUF3QixBQUFDO0FBS2pELEFBQU0sYUFBdUMsK0JBQVEsQUFBTTtBQUEzRDs7QUFLRSxhQUFXLGNBQUcsQUFBQyxBQUFDLEFBc1VsQjtBQUFDO0FBcFVDLEFBQU07QUFDSixBQUFPLDBCQUFXLEFBQUksS0FBQyxBQUFXLEFBQUUsYUFBRyxBQUFDLEFBQzFDO0FBQUM7QUFFRCxBQUFPLFlBQUMsQUFBOEI7QUFDcEMsWUFBSSxBQUFJLE9BQW9CLEFBQUUsQUFBQztBQUMvQixBQUFJLGFBQUMsQUFBVyxjQUFHLEFBQUMsQUFBQztBQUNyQixZQUFJLEFBQUksT0FBRyxBQUFDLEVBQUMsQUFBTyxRQUFDLEFBQUksTUFBRSxBQUFPLFFBQUMsQUFBVyxhQUFFLEFBQU8sUUFBQyxBQUFHLEFBQUMsQUFBQztBQUM3RCxZQUFJLEFBQUM7WUFDSCxBQUFDLElBQUcsQUFBTyxRQUFDLEFBQUksS0FBQyxBQUFNLEFBQUM7QUFFMUIsQUFBSSxhQUFDLEFBQVksYUFBQyxBQUFJLEtBQUMsQUFBSSxBQUFDLEFBQUM7QUFFN0IsWUFBSSxBQUFDLE1BQUssQUFBQyxHQUFFO0FBQ1gsbUJBQU8sQUFBSSxLQUFDLEFBQVksYUFBQyxBQUFHLEFBQWlCLEFBQUM7QUFDL0M7QUFFRCxhQUFLLEFBQUMsSUFBRyxBQUFDLEdBQUUsQUFBQyxJQUFHLEFBQUMsR0FBRSxBQUFDLEFBQUUsS0FBRTtBQUN0QixBQUFJLGlCQUFDLEFBQVUsV0FBQyxBQUFPLFFBQUMsQUFBSSxLQUFDLEFBQUMsQUFBQyxBQUFDLEFBQUM7QUFDbEM7QUFFRCxBQUEyRDtBQUMzRCxZQUFJLEFBQVUsYUFBRyxBQUFJLEtBQUMsQUFBWSxhQUFDLEFBQUcsQUFBRSxBQUFDO0FBQ3pDLFlBQUksQUFBVSxlQUFLLEFBQUksTUFBRTtBQUN2QixnQkFBSSxBQUFXLGNBQUcsQUFBNkIsQUFBQztBQUVoRCxrQkFBTSxJQUFJLEFBQVcsWUFDbkIsQUFBb0IsdUJBQUcsQUFBVyxZQUFDLEFBQUcsTUFBRyxBQUFhLGdCQUFHLEFBQVcsWUFBQyxBQUFJLElBQUMsQUFBSyxNQUFDLEFBQUksT0FBRyxBQUFJLE1BQzNGLEFBQVcsWUFBQyxBQUFHLEFBQ2hCLEFBQUM7QUFDSDtBQUVELGVBQU8sQUFBSSxBQUFDLEFBQ2Q7QUFBQztBQUVELEFBQWMsbUJBQUMsQUFBbUM7QUFDaEQsWUFBSSxBQUFJLEtBQUMsQUFBUyxVQUFDLEFBQU8sQUFBQyxhQUFLLEFBQVMsV0FBRTtBQUN6QyxBQUFJLGlCQUFDLEFBQW1CLG9CQUFDLEFBQUksS0FBQyxBQUFhLGNBQUMsQUFBSyxBQUFDLEFBQUMsQUFBQztBQUNwRCxBQUFPO0FBQ1I7QUFFRCxZQUNFLEFBQUksS0FBQyxBQUFTLFVBQUMsQUFBTyxBQUFDLGFBQUssQUFBUyxhQUNyQyxBQUFJLEtBQUMsQUFBUyxVQUFDLEFBQU8sQUFBQyxhQUFLLEFBQU0sVUFDbEMsQUFBSSxLQUFDLEFBQVMsVUFBQyxBQUFPLEFBQUMsYUFBSyxBQUFZLGNBQ3hDO0FBQ0Esa0JBQU0sSUFBSSxBQUFXLFlBQ25CLEFBQW1FLHFFQUNuRSxBQUFLLE1BQUMsQUFBRyxBQUNWLEFBQUM7QUFDSDtBQUVELFlBQUksRUFBRSxBQUFJLE1BQUUsQUFBTSxRQUFFLEFBQUksQUFBRSxTQUFHLEFBQWUsZ0JBQUMsQUFBSSxNQUFFLEFBQUssQUFBQyxBQUFDO0FBQzFELFlBQUksQUFBTyxVQUFHLEFBQUksS0FBQyxBQUFPLFFBQUMsQUFBSyxNQUFDLEFBQU8sQUFBQyxBQUFDO0FBQzFDLFlBQUksQUFBTyxVQUFHLEFBQUssTUFBQyxBQUFPLEFBQUMsQUFBQyxVQUFDLEFBQUksS0FBQyxBQUFPLFFBQUMsQUFBSyxNQUFDLEFBQU8sQUFBQyxBQUFDLEFBQUMsV0FBQyxBQUFJLEFBQUM7QUFFakUsWUFBSSxBQUFJLEtBQUMsQUFBUSxhQUFLLEFBQVksY0FBRTtBQUNsQyxBQUFJLG1CQUFHLEFBQWdCLGlCQUFDLEFBQUksS0FBQyxBQUFNLEFBQUUsVUFBRSxBQUFJLE1BQUUsQUFBSyxNQUFDLEFBQUcsQUFBQyxBQUFDO0FBQ3pEO0FBRUQsWUFBSSxBQUFJLE9BQUcsQUFBQyxFQUFDLEFBQUssTUFBQyxBQUFJLE1BQUUsQUFBTSxRQUFFLEFBQUksTUFBRSxBQUFPLFNBQUUsQUFBTyxTQUFFLEFBQUssTUFBQyxBQUFHLEFBQUMsQUFBQztBQUVwRSxZQUFJLEFBQWEsZ0JBQUcsQUFBSSxLQUFDLEFBQWMsQUFBRSxBQUFDO0FBQzFDLEFBQVcsb0JBQUMsQUFBYSxlQUFFLEFBQUksQUFBQyxBQUFDLEFBQ25DO0FBQUM7QUFFRCxBQUFpQixzQkFBQyxBQUE0QztBQUM1RCxZQUFJLEVBQUUsQUFBUyxBQUFFLGNBQUcsQUFBSSxBQUFDO0FBRXpCLFlBQUksQUFBUyxVQUFDLEFBQU8sQUFBQyxhQUFLLEFBQVMsV0FBRTtBQUNwQyxBQUFJLGlCQUFDLEFBQW1CLG9CQUFDLEFBQUksS0FBQyxBQUFhLGNBQUMsQUFBVyxBQUFDLEFBQUMsQUFBQztBQUMxRCxBQUFPO0FBQ1I7QUFFRCxZQUFJLEFBQStCLEFBQUM7QUFDcEMsWUFBSSxFQUFFLEFBQU8sU0FBRSxBQUFHLEFBQUUsUUFBRyxBQUFXLEFBQUM7QUFFbkMsWUFBSSxBQUFXLFlBQUMsQUFBSSxLQUFDLEFBQUksS0FBQyxBQUFLLE1BQUMsQUFBVSxBQUFDLGFBQUU7QUFDM0MsQUFBUTtBQUNOLEFBQUksc0JBQUUsQUFBbUI7QUFDekIsQUFBSSxzQkFBRSxBQUFJLEtBQUMsQUFBVSxXQUFjLEFBQVcsWUFBQyxBQUFJLEFBQUM7QUFDcEQsQUFBTSx3QkFBRSxBQUFFO0FBQ1YsQUFBSSxzQkFBRSxBQUFDLEVBQUMsQUFBSSxBQUFFO0FBQ2QsQUFBTztBQUNQLEFBQUcsQUFDSixBQUFDO0FBUFM7QUFRWixlQUFNO0FBQ0wsZ0JBQUksRUFBRSxBQUFJLE1BQUUsQUFBTSxRQUFFLEFBQUksQUFBRSxTQUFHLEFBQWUsZ0JBQzFDLEFBQUksTUFDSixBQUVDLEFBQ0YsQUFBQztBQUNGLEFBQVEsdUJBQUcsQUFBQyxFQUFDLEFBQVEsU0FBQyxBQUFJLE1BQUUsQUFBTSxRQUFFLEFBQUksTUFBRSxDQUFDLEFBQU8sU0FBRSxBQUFHLEFBQUMsQUFBQztBQUMxRDtBQUVELGdCQUFRLEFBQVMsVUFBQyxBQUFLLEFBQUU7QUFDdkIsQUFBYztBQUNkO0FBQ0UsQUFBa0IsbUNBQUMsQUFBSSxLQUFDLEFBQWUsaUJBQUUsQUFBUSxBQUFDLEFBQUM7QUFDbkQsQUFBUywwQkFBQyxBQUFZLG1DQUFvQyxBQUFDO0FBQzNELEFBQU07QUFDUjtBQUNFLEFBQWtCLG1DQUFDLEFBQUksS0FBQyxBQUFlLGlCQUFFLEFBQVEsQUFBQyxBQUFDO0FBQ25ELEFBQU07QUFDUixpQ0FBa0M7QUFDbEM7QUFDRSxBQUFJLHFCQUFDLEFBQW1CLG9CQUFDLEFBQUssQUFBQyxBQUFDO0FBQ2hDLEFBQUkscUJBQUMsQUFBb0IsQUFBRSxBQUFDO0FBQzVCLEFBQWtCLG1DQUFDLEFBQUksS0FBQyxBQUFlLGlCQUFFLEFBQVEsQUFBQyxBQUFDO0FBQ25ELEFBQVMsMEJBQUMsQUFBWSxtQ0FBb0MsQUFBQztBQUMzRCxBQUFNO0FBQ1I7QUFDRSxBQUFrQixtQ0FBQyxBQUFJLEtBQUMsQUFBZSxpQkFBRSxBQUFRLEFBQUMsQUFBQztBQUNuRCxBQUFTLDBCQUFDLEFBQVksbUNBQW9DLEFBQUM7QUFDM0QsQUFBTTtBQUVSLEFBQW1CO0FBQ25CO0FBQ0UsQUFBSSxxQkFBQyxBQUFtQixvQkFBQyxBQUFLLEFBQUMsQUFBQztBQUNoQyxBQUErQixnREFBQyxBQUFJLEtBQUMsQUFBaUIsa0JBQUUsQUFBUSxBQUFDLEFBQUM7QUFDbEUsQUFBUywwQkFBQyxBQUFZLHNDQUF1QyxBQUFDO0FBQzlELEFBQU07QUFDUiw4Q0FBK0M7QUFDL0MsOENBQStDO0FBQy9DO0FBQ0UsQUFBK0IsZ0RBQUMsQUFBSSxLQUFDLEFBQWlCLGtCQUFFLEFBQVEsQUFBQyxBQUFDO0FBQ2xFLEFBQU07QUFFUixBQUF5RDtBQUN6RCxBQUE0QztBQUM1QztBQUNFLEFBQVcsNEJBQUMsQUFBSSxLQUFDLEFBQWMsQUFBRSxrQkFBRSxBQUFRLEFBQUMsQUFBQyxBQUNoRDs7QUFFRCxlQUFPLEFBQVEsQUFBQyxBQUNsQjtBQUFDO0FBRUQsQUFBZ0IscUJBQUMsQUFBdUM7QUFDdEQsQUFBdUIsZ0NBQUMsQUFBSSxLQUFDLEFBQVMsV0FBRSxBQUFPLEFBQUMsQUFBQztBQUVqRCxBQUFJLGFBQUMsQUFBUyxVQUFDLEFBQVksYUFBQyxBQUFPLFFBQUMsQUFBSyxBQUFDLEFBQUM7QUFDM0MsQUFBSSxhQUFDLEFBQVMsVUFBQyxBQUFTLEFBQUUsQUFBQyxBQUM3QjtBQUFDO0FBRUQsQUFBZ0IscUJBQ2QsQUFBMEM7QUFFMUMsWUFBSSxFQUFFLEFBQVMsQUFBRSxjQUFHLEFBQUksQUFBQztBQUV6QixZQUFJLEFBQVMsVUFBQyxBQUFLLG9CQUEyQixlQUFFO0FBQzlDLEFBQUkscUJBQUMsQUFBbUIsb0JBQUMsQUFBSSxLQUFDLEFBQWEsY0FBQyxBQUFVLEFBQUMsQUFBQyxBQUFDO0FBQ3pELHVCQUFPLEFBQUksQUFBQztBQUNiO0FBRUQsWUFBSSxFQUFFLEFBQUssT0FBRSxBQUFHLEFBQUUsUUFBRyxBQUFVLEFBQUM7QUFDaEMsWUFBSSxBQUFPLFVBQUcsQUFBQyxFQUFDLEFBQWUsZ0JBQUMsQUFBSyxPQUFFLEFBQUcsQUFBQyxBQUFDO0FBRTVDLGdCQUFRLEFBQVMsVUFBQyxBQUFLLEFBQUU7QUFDdkI7QUFDRSxBQUFJLHFCQUFDLEFBQWUsZ0JBQUMsQUFBUSxTQUFDLEFBQUksS0FBQyxBQUFPLEFBQUMsQUFBQztBQUM1QyxBQUFNO0FBRVIsOEJBQStCO0FBQy9CO0FBQ0UsQUFBVyw0QkFBQyxBQUFJLEtBQUMsQUFBYyxBQUFFLGtCQUFFLEFBQU8sQUFBQyxBQUFDO0FBQzVDLEFBQU07QUFFUjtBQUNFLHNCQUFNLElBQUksQUFBVyxBQUNuQix3REFDRSxBQUFTLFVBQUMsQUFBTyxBQUNuQix1Q0FBK0IsQUFBTyxRQUFDLEFBQUssa0JBQWEsQUFBRyxJQUFDLEFBQUssTUFBQyxBQUFJLFFBQ3JFLEFBQUcsSUFBQyxBQUFLLE1BQUMsQUFDWixNQUFFLElBQ0YsQUFBVSxXQUFDLEFBQUcsQUFDZixBQUFDLEFBQ0w7O0FBRUQsZUFBTyxBQUFPLEFBQUMsQUFDakI7QUFBQztBQUVELEFBQWdCLHFCQUFDLEFBQXVDO0FBQ3RELFlBQUksRUFBRSxBQUFHLEFBQUUsUUFBRyxBQUFPLEFBQUM7QUFFdEIsY0FBTSxJQUFJLEFBQVcsQUFDbkIsdURBQTJDLEFBQUksS0FBQyxBQUFhLGNBQUMsQUFBTyxTQUFFLEFBQU8sUUFBQyxBQUFJLEFBQUMsY0FDbEYsQUFBRyxJQUFDLEFBQUssTUFBQyxBQUNaLFNBQUssQUFBRyxJQUFDLEFBQUssTUFBQyxBQUFNLE1BQUUsSUFDdkIsQUFBTyxRQUFDLEFBQUcsQUFDWixBQUFDLEFBQ0o7QUFBQztBQUVELEFBQXFCLDBCQUFDLEFBQWlEO0FBQ3JFLFlBQUksRUFBRSxBQUFHLEFBQUUsUUFBRyxBQUFZLEFBQUM7QUFFM0IsY0FBTSxJQUFJLEFBQVcsQUFDbkIsNkRBQWlELEFBQUksS0FBQyxBQUFhLGNBQ2pFLEFBQVksY0FDWixBQUFZLGFBQUMsQUFBSSxBQUNsQixjQUFTLEFBQUcsSUFBQyxBQUFLLE1BQUMsQUFBSSxTQUFLLEFBQUcsSUFBQyxBQUFLLE1BQUMsQUFBTSxNQUFFLElBQy9DLEFBQVksYUFBQyxBQUFHLEFBQ2pCLEFBQUMsQUFDSjtBQUFDO0FBRUQsQUFBUyxjQUFDLEFBQWtDO0FBQzFDLFlBQUksRUFBRSxBQUFHLEFBQUUsUUFBRyxBQUFTLEFBQUM7QUFFeEIsY0FBTSxJQUFJLEFBQVcsQUFDbkIseURBQTZDLEFBQUksS0FBQyxBQUFhLGNBQzdELEFBQVMsV0FDVCxBQUFTLFVBQUMsQUFBSSxBQUNmLGNBQVMsQUFBRyxJQUFDLEFBQUssTUFBQyxBQUFJLFNBQUssQUFBRyxJQUFDLEFBQUssTUFBQyxBQUFNLE1BQUUsSUFDL0MsQUFBUyxVQUFDLEFBQUcsQUFDZCxBQUFDLEFBQ0o7QUFBQztBQUVELEFBQWMsbUJBQUMsQUFBNEM7QUFDekQsWUFBSSxFQUFFLEFBQUcsQUFBRSxRQUFHLEFBQWMsQUFBQztBQUU3QixjQUFNLElBQUksQUFBVyxBQUNuQiwrREFBbUQsQUFBSSxLQUFDLEFBQWEsY0FDbkUsQUFBYyxnQkFDZCxBQUFjLGVBQUMsQUFBSSxBQUNwQixjQUFTLEFBQUcsSUFBQyxBQUFLLE1BQUMsQUFBSSxTQUFLLEFBQUcsSUFBQyxBQUFLLE1BQUMsQUFBTSxNQUFFLElBQy9DLEFBQWMsZUFBQyxBQUFHLEFBQ25CLEFBQUMsQUFDSjtBQUFDO0FBRUQsQUFBYSxrQkFBQyxBQUFrQztBQUM5QyxZQUFJLEVBQUUsQUFBSSxNQUFFLEFBQU0sUUFBRSxBQUFJLEFBQUUsU0FBRyxBQUFlLGdCQUFDLEFBQUksTUFBRSxBQUFLLEFBQUMsQUFBQztBQUMxRCxlQUFPLEFBQUMsRUFBQyxBQUFLLE1BQUMsQUFBSSxNQUFFLEFBQU0sUUFBRSxBQUFJLE1BQUUsQUFBSyxNQUFDLEFBQUcsQUFBQyxBQUFDLEFBQ2hEO0FBQUM7QUFFRCxBQUFjLG1CQUFDLEFBQWtDO0FBQy9DLFlBQUksRUFBRSxBQUFRLFVBQUUsQUFBRyxBQUFFLFFBQUcsQUFBSSxBQUFDO0FBQzdCLFlBQUksQUFBZSxBQUFDO0FBRXBCLFlBQUksQUFBUSxTQUFDLEFBQU8sUUFBQyxBQUFHLEFBQUMsU0FBSyxDQUFDLEFBQUMsR0FBRTtBQUNoQyxnQkFBSSxBQUFRLFNBQUMsQUFBSyxNQUFDLEFBQUMsR0FBRSxBQUFDLEFBQUMsT0FBSyxBQUFJLE1BQUU7QUFDakMsc0JBQU0sSUFBSSxBQUFXLEFBQ25CLHdFQUE0RCxBQUFJLEtBQUMsQUFBUSxxQkFDdkUsQUFBRyxJQUFDLEFBQUssTUFBQyxBQUNaLElBQUcsS0FDSCxBQUFJLEtBQUMsQUFBRyxBQUNULEFBQUM7QUFDSDtBQUNELGdCQUFJLEFBQVEsU0FBQyxBQUFLLE1BQUMsQUFBQyxHQUFFLEFBQUMsQUFBQyxPQUFLLEFBQUssT0FBRTtBQUNsQyxzQkFBTSxJQUFJLEFBQVcsQUFDbkIsMEVBQThELEFBQUksS0FBQyxBQUFRLHFCQUN6RSxBQUFHLElBQUMsQUFBSyxNQUFDLEFBQ1osSUFBRyxLQUNILEFBQUksS0FBQyxBQUFHLEFBQ1QsQUFBQztBQUNIO0FBQ0QsZ0JBQUksQUFBUSxTQUFDLEFBQU8sUUFBQyxBQUFHLEFBQUMsU0FBSyxDQUFDLEFBQUMsR0FBRTtBQUNoQyxzQkFBTSxJQUFJLEFBQVcsQUFDbkIsa0hBQ0UsQUFBSSxLQUFDLEFBQ1AscUJBQWEsQUFBRyxJQUFDLEFBQUssTUFBQyxBQUFJLElBQUcsS0FDOUIsQUFBSSxLQUFDLEFBQUcsQUFDVCxBQUFDO0FBQ0g7QUFDRCxBQUFLLG9CQUFHLENBQUMsQUFBSSxLQUFDLEFBQUssTUFBQyxBQUFJLEtBQUMsQUFBRyxBQUFDLEFBQUMsQUFBQztBQUNoQyxlQUFNO0FBQ0wsQUFBSyxvQkFBRyxBQUFJLEtBQUMsQUFBSyxBQUFDO0FBQ3BCO0FBRUQsWUFBSSxBQUFRLFdBQUcsQUFBSyxBQUFDO0FBRXJCLEFBQTJFO0FBQzNFLEFBQTJFO0FBQzNFLEFBQXdFO0FBQ3hFLEFBQXlFO0FBQ3pFLEFBQXlFO0FBQ3pFLEFBQXNFO0FBQ3RFLEFBQXdFO0FBQ3hFLEFBQXdFO0FBQ3hFLEFBQXlFO0FBQ3pFLEFBQW9CO0FBQ3BCLFlBQUksQUFBUSxTQUFDLEFBQUssTUFBQyxBQUFlLEFBQUMsa0JBQUU7QUFDbkMsQUFBUSx1QkFBRyxBQUFJLEFBQUM7QUFDakI7QUFFRDtBQUNFLEFBQUksa0JBQUUsQUFBZ0I7QUFDdEIsQUFBUSxzQkFBRSxBQUFJLEtBQUMsQUFBUTtBQUN2QixBQUFJLGtCQUFFLEFBQVE7QUFDZCxBQUFLO0FBQ0wsQUFBSSxrQkFBRSxBQUFJLEtBQUMsQUFBSTtBQUNmLEFBQUcsaUJBQUUsQUFBSSxLQUFDLEFBQUcsQUFDZCxBQUFDLEFBQ0o7QUFSUztBQVFSO0FBRUQsQUFBSSxTQUFDLEFBQXdCO0FBQzNCLFlBQUksQUFBSyxRQUFtQixBQUFFLEFBQUM7QUFFL0IsYUFBSyxJQUFJLEFBQUMsSUFBRyxBQUFDLEdBQUUsQUFBQyxJQUFHLEFBQUksS0FBQyxBQUFLLE1BQUMsQUFBTSxRQUFFLEFBQUMsQUFBRSxLQUFFO0FBQzFDLGdCQUFJLEFBQUksT0FBRyxBQUFJLEtBQUMsQUFBSyxNQUFDLEFBQUMsQUFBQyxBQUFDO0FBQ3pCLEFBQUssa0JBQUMsQUFBSSxLQUFDLEFBQUMsRUFBQyxBQUFJLEtBQUMsQUFBSSxLQUFDLEFBQUcsS0FBRSxBQUFJLEtBQUMsQUFBVSxXQUFpQixBQUFJLEtBQUMsQUFBSyxBQUFDLFFBQUUsQUFBSSxLQUFDLEFBQUcsQUFBQyxBQUFDLEFBQUM7QUFDckY7QUFFRCxlQUFPLEFBQUMsRUFBQyxBQUFJLEtBQUMsQUFBSyxPQUFFLEFBQUksS0FBQyxBQUFHLEFBQUMsQUFBQyxBQUNqQztBQUFDO0FBRUQsQUFBYSxrQkFBQyxBQUFtQztBQUMvQyxlQUFPLEFBQUMsRUFBQyxBQUFPLFFBQUMsQUFBZSxpQkFBRSxBQUFNLE9BQUMsQUFBSyxPQUFFLEFBQU0sT0FBQyxBQUFHLEFBQUMsQUFBQyxBQUM5RDtBQUFDO0FBRUQsQUFBYyxtQkFBQyxBQUFxQztBQUNsRCxlQUFPLEFBQUMsRUFBQyxBQUFPLFFBQUMsQUFBZ0Isa0JBQUUsQUFBTyxRQUFDLEFBQUssT0FBRSxBQUFPLFFBQUMsQUFBRyxBQUFDLEFBQUMsQUFDakU7QUFBQztBQUVELEFBQWEsa0JBQUMsQUFBbUM7QUFDL0MsZUFBTyxBQUFDLEVBQUMsQUFBTyxRQUFDLEFBQWUsaUJBQUUsQUFBTSxPQUFDLEFBQUssT0FBRSxBQUFNLE9BQUMsQUFBRyxBQUFDLEFBQUMsQUFDOUQ7QUFBQztBQUVELEFBQWdCLHFCQUFDLEFBQXFDO0FBQ3BELGVBQU8sQUFBQyxFQUFDLEFBQU8sUUFBQyxBQUFrQixvQkFBRSxBQUFTLFdBQUUsQUFBSyxNQUFDLEFBQUcsQUFBQyxBQUFDLEFBQzdEO0FBQUM7QUFFRCxBQUFXLGdCQUFDLEFBQThCO0FBQ3hDLGVBQU8sQUFBQyxFQUFDLEFBQU8sUUFBQyxBQUFhLGVBQUUsQUFBSSxNQUFFLEFBQUcsSUFBQyxBQUFHLEFBQUMsQUFBQyxBQUNqRDtBQUFDLEFBQ0Y7O0FBRUQsdUNBQXVDLEFBQWdCLFVBQUUsQUFBYTtBQUNwRSxRQUFJLEFBQUssVUFBSyxBQUFFLElBQUU7QUFDaEIsQUFBb0Q7QUFDcEQsQUFBYztBQUNkO0FBQ0UsQUFBSyxtQkFBRSxBQUFRLFNBQUMsQUFBSyxNQUFDLEFBQUksQUFBQyxNQUFDLEFBQU0sU0FBRyxBQUFDO0FBQ3RDLEFBQU8scUJBQUUsQUFBQyxBQUNYLEFBQUM7QUFISztBQUlSO0FBRUQsQUFBb0Q7QUFDcEQsQUFBVTtBQUNWLFFBQUksQUFBVSxhQUFHLEFBQVEsU0FBQyxBQUFLLE1BQUMsQUFBSyxBQUFDLE9BQUMsQUFBQyxBQUFDLEFBQUM7QUFDMUMsUUFBSSxBQUFLLFFBQUcsQUFBVSxXQUFDLEFBQUssTUFBQyxBQUFJLEFBQUMsQUFBQztBQUNuQyxRQUFJLEFBQVMsWUFBRyxBQUFLLE1BQUMsQUFBTSxTQUFHLEFBQUMsQUFBQztBQUVqQztBQUNFLEFBQUssZUFBRSxBQUFTO0FBQ2hCLEFBQU8saUJBQUUsQUFBSyxNQUFDLEFBQVMsQUFBQyxXQUFDLEFBQU0sQUFDakMsQUFBQyxBQUNKO0FBSlM7QUFJUjtBQUVELGlDQUNFLEFBQThCLFdBQzlCLEFBQXVDO0FBRXZDLFFBQUksQUFBSSxPQUFHLEFBQU8sUUFBQyxBQUFHLElBQUMsQUFBSyxNQUFDLEFBQUksQUFBQztBQUNsQyxRQUFJLEFBQU0sU0FBRyxBQUFPLFFBQUMsQUFBRyxJQUFDLEFBQUssTUFBQyxBQUFNLEFBQUM7QUFFdEMsUUFBSSxBQUFPLFVBQUcsQUFBNkIsOEJBQ3pDLEFBQU8sUUFBQyxBQUFvRCxVQUM1RCxBQUFPLFFBQUMsQUFBSyxBQUNkLEFBQUM7QUFFRixBQUFJLFdBQUcsQUFBSSxPQUFHLEFBQU8sUUFBQyxBQUFLLEFBQUM7QUFDNUIsUUFBSSxBQUFPLFFBQUMsQUFBSyxPQUFFO0FBQ2pCLEFBQU0saUJBQUcsQUFBTyxRQUFDLEFBQU8sQUFBQztBQUMxQixXQUFNO0FBQ0wsQUFBTSxpQkFBRyxBQUFNLFNBQUcsQUFBTyxRQUFDLEFBQU8sQUFBQztBQUNuQztBQUVELEFBQVMsY0FBQyxBQUFJLE9BQUcsQUFBSSxBQUFDO0FBQ3RCLEFBQVMsY0FBQyxBQUFNLFNBQUcsQUFBTSxBQUFDLEFBQzVCO0FBQUM7QUFFRCx5QkFDRSxBQUFnQyxVQUNoQyxBQUlDO0FBRUQsUUFBSSxBQUFJLE9BQUcsQUFBUSxTQUFDLEFBQWMsZUFBQyxBQUFJLEtBQUMsQUFBSSxBQUFDLEFBQUM7QUFFOUMsUUFBSSxBQUFNLFNBQUcsQUFBSSxLQUFDLEFBQU0sQUFBQyxBQUFDLFNBQUMsQUFBSSxLQUFDLEFBQU0sT0FBQyxBQUFHLElBQUMsQUFBQyxBQUFDLEFBQUUsS0FBQyxBQUFRLFNBQUMsQUFBVSxXQUFpQixBQUFDLEFBQUMsQUFBQyxBQUFDLEFBQUMsTUFBQyxBQUFFLEFBQUM7QUFDN0YsUUFBSSxBQUFJLE9BQUcsQUFBSSxLQUFDLEFBQUksQUFBQyxBQUFDLE9BQUMsQUFBUSxTQUFDLEFBQUksS0FBQyxBQUFJLEtBQUMsQUFBSSxBQUFDLEFBQUMsQUFBQyxRQUFDLEFBQUMsRUFBQyxBQUFJLEFBQUUsQUFBQztBQUUzRCxXQUFPLEVBQUUsQUFBSSxNQUFFLEFBQU0sUUFBRSxBQUFJLEFBQUUsQUFBQyxBQUNoQztBQUFDO0FBRUQsNEJBQTRCLEFBQXdCLFNBQUUsQUFBK0I7QUFDbkYsUUFBSSxFQUFFLEFBQUksTUFBRSxBQUFNLFFBQUUsQUFBSSxNQUFFLEFBQUcsQUFBRSxRQUFHLEFBQVEsQUFBQztBQUUzQyxRQUFJLEFBQVMsVUFBQyxBQUFJLEFBQUMsT0FBRTtBQUNuQixZQUFJLEFBQVEsQUFBRyxnQkFBSyxBQUFZLGFBQUMsQUFBSSxBQUFDLEtBQUksQUFBQztBQUMzQyxZQUFJLEFBQUcsQUFBRyxVQUFJLEFBQU8sUUFBQyxBQUFJLFlBQVEsQUFBUSxRQUFNLEFBQUM7QUFFakQsY0FBTSxJQUFJLEFBQVcsQUFDbkIsa0JBQU0sQUFBRyxRQUFLLEFBQVEsc0NBQThCLEFBQUksS0FBQyxBQUFRLHFCQUFhLEFBQUcsT0FDL0UsQUFBRyxJQUFDLEFBQUssTUFBQyxBQUFJLElBQUcsS0FDbkIsQUFBUSxTQUFDLEFBQUcsQUFDYixBQUFDO0FBQ0g7QUFFRCxRQUFJLEFBQVEsV0FBRyxBQUFDLEVBQUMsQUFBZSxnQkFBQyxBQUFJLE1BQUUsQUFBTSxRQUFFLEFBQUksTUFBRSxBQUFHLEFBQUMsQUFBQztBQUMxRCxBQUFPLFlBQUMsQUFBUyxVQUFDLEFBQUksS0FBQyxBQUFRLEFBQUMsQUFBQyxBQUNuQztBQUFDO0FBRUQsMEJBQTBCLEFBQWMsUUFBRSxBQUFjLE1BQUUsQUFBdUI7QUFDL0UsUUFBSSxBQUFjLGlCQUFHLEFBQUssQUFBQztBQUMzQixBQUFJLFNBQUMsQUFBSyxNQUFDLEFBQU8sUUFBQyxBQUFJLEFBQUMsQUFBRTtBQUN4QixZQUFJLEFBQUksS0FBQyxBQUFHLFFBQUssQUFBTSxRQUFFO0FBQ3ZCLGtCQUFNLElBQUksQUFBVyxZQUFDLEFBQW9DLHNDQUFFLEFBQUcsQUFBQyxBQUFDO0FBQ2xFO0FBRUQsWUFBSSxBQUFJLEtBQUMsQUFBRyxRQUFLLEFBQWEsZUFBRTtBQUM5QixBQUFjLDZCQUFHLEFBQUksQUFBQztBQUN2QixBQUNIO0FBQUMsQUFBQyxBQUFDO0FBRUgsUUFBSSxBQUFJLE9BQUcsQUFBQyxFQUFDLEFBQU8sUUFBQyxBQUFlLGlCQUFFLEFBQU0sQUFBQyxBQUFDO0FBQzlDLFFBQUksQUFBUSxXQUFHLEFBQUMsRUFBQyxBQUFJLEtBQUMsQUFBTSxRQUFFLEFBQUksQUFBQyxBQUFDO0FBQ3BDLEFBQUksU0FBQyxBQUFLLE1BQUMsQUFBTyxRQUFDLEFBQVEsQUFBQyxBQUFDO0FBRTdCLFFBQUksQ0FBQyxBQUFjLGdCQUFFO0FBQ25CLFlBQUksQUFBVyxjQUFHLEFBQUMsRUFBQyxBQUFPLFFBQUMsQUFBYSxlQUFFLEFBQUksQUFBQyxBQUFDO0FBQ2pELFlBQUksQUFBVyxjQUFHLEFBQUMsRUFBQyxBQUFJLEtBQUMsQUFBYSxlQUFFLEFBQVcsQUFBQyxBQUFDO0FBQ3JELEFBQUksYUFBQyxBQUFLLE1BQUMsQUFBSSxLQUFDLEFBQVcsQUFBQyxBQUFDO0FBQzlCO0FBRUQsV0FBTyxBQUFJLEFBQUMsQUFDZDtBQUFDO0FBRUQseUNBQXlDLEFBQW9CLFdBQUUsQUFBMkI7QUFDeEYsQUFBUyxjQUFDLEFBQVMsWUFBRyxBQUFJLEFBQUM7QUFDM0IsQUFBUyxjQUFDLEFBQUssTUFBQyxBQUFJLEtBQUMsQUFBSSxBQUFDLEFBQUMsQUFDN0I7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCB7IGFwcGVuZENoaWxkLCBpc0xpdGVyYWwsIHByaW50TGl0ZXJhbCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5pbXBvcnQgKiBhcyBIYW5kbGViYXJzQVNUIGZyb20gJy4uL3R5cGVzL2hhbmRsZWJhcnMtYXN0JztcbmltcG9ydCB7IFBhcnNlciwgVGFnLCBBdHRyaWJ1dGUgfSBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IFN5bnRheEVycm9yIGZyb20gJy4uL2Vycm9ycy9zeW50YXgtZXJyb3InO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBSZWNhc3QgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFRva2VuaXplclN0YXRlIH0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMgZXh0ZW5kcyBQYXJzZXIge1xuICBhYnN0cmFjdCBhcHBlbmRUb0NvbW1lbnREYXRhKHM6IHN0cmluZyk6IHZvaWQ7XG4gIGFic3RyYWN0IGJlZ2luQXR0cmlidXRlVmFsdWUocXVvdGVkOiBib29sZWFuKTogdm9pZDtcbiAgYWJzdHJhY3QgZmluaXNoQXR0cmlidXRlVmFsdWUoKTogdm9pZDtcblxuICBjdXJzb3JDb3VudCA9IDA7XG5cbiAgY3Vyc29yKCkge1xuICAgIHJldHVybiBgJWN1cnNvcjoke3RoaXMuY3Vyc29yQ291bnQrK30lYDtcbiAgfVxuXG4gIFByb2dyYW0ocHJvZ3JhbTogSGFuZGxlYmFyc0FTVC5Qcm9ncmFtKTogQVNULlByb2dyYW0ge1xuICAgIGxldCBib2R5OiBBU1QuU3RhdGVtZW50W10gPSBbXTtcbiAgICB0aGlzLmN1cnNvckNvdW50ID0gMDtcbiAgICBsZXQgbm9kZSA9IGIucHJvZ3JhbShib2R5LCBwcm9ncmFtLmJsb2NrUGFyYW1zLCBwcm9ncmFtLmxvYyk7XG4gICAgbGV0IGksXG4gICAgICBsID0gcHJvZ3JhbS5ib2R5Lmxlbmd0aDtcblxuICAgIHRoaXMuZWxlbWVudFN0YWNrLnB1c2gobm9kZSk7XG5cbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpIGFzIEFTVC5Qcm9ncmFtO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuYWNjZXB0Tm9kZShwcm9ncmFtLmJvZHlbaV0pO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoYXQgdGhlIGVsZW1lbnQgc3RhY2sgaXMgYmFsYW5jZWQgcHJvcGVybHkuXG4gICAgbGV0IHBvcHBlZE5vZGUgPSB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKTtcbiAgICBpZiAocG9wcGVkTm9kZSAhPT0gbm9kZSkge1xuICAgICAgbGV0IGVsZW1lbnROb2RlID0gcG9wcGVkTm9kZSBhcyBBU1QuRWxlbWVudE5vZGU7XG5cbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgJ1VuY2xvc2VkIGVsZW1lbnQgYCcgKyBlbGVtZW50Tm9kZS50YWcgKyAnYCAob24gbGluZSAnICsgZWxlbWVudE5vZGUubG9jIS5zdGFydC5saW5lICsgJykuJyxcbiAgICAgICAgZWxlbWVudE5vZGUubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgQmxvY2tTdGF0ZW1lbnQoYmxvY2s6IEhhbmRsZWJhcnNBU1QuQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICBpZiAodGhpcy50b2tlbml6ZXJbJ3N0YXRlJ10gPT09ICdjb21tZW50Jykge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShibG9jaykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMudG9rZW5pemVyWydzdGF0ZSddICE9PSAnY29tbWVudCcgJiZcbiAgICAgIHRoaXMudG9rZW5pemVyWydzdGF0ZSddICE9PSAnZGF0YScgJiZcbiAgICAgIHRoaXMudG9rZW5pemVyWydzdGF0ZSddICE9PSAnYmVmb3JlRGF0YSdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgJ0EgYmxvY2sgbWF5IG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gSFRNTCBlbGVtZW50IG9yIGFub3RoZXIgYmxvY2suJyxcbiAgICAgICAgYmxvY2subG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIGJsb2NrKTtcbiAgICBsZXQgcHJvZ3JhbSA9IHRoaXMuUHJvZ3JhbShibG9jay5wcm9ncmFtKTtcbiAgICBsZXQgaW52ZXJzZSA9IGJsb2NrLmludmVyc2UgPyB0aGlzLlByb2dyYW0oYmxvY2suaW52ZXJzZSkgOiBudWxsO1xuXG4gICAgaWYgKHBhdGgub3JpZ2luYWwgPT09ICdpbi1lbGVtZW50Jykge1xuICAgICAgaGFzaCA9IGFkZEluRWxlbWVudEhhc2godGhpcy5jdXJzb3IoKSwgaGFzaCwgYmxvY2subG9jKTtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IGIuYmxvY2socGF0aCwgcGFyYW1zLCBoYXNoLCBwcm9ncmFtLCBpbnZlcnNlLCBibG9jay5sb2MpO1xuXG4gICAgbGV0IHBhcmVudFByb2dyYW0gPSB0aGlzLmN1cnJlbnRFbGVtZW50KCk7XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50UHJvZ3JhbSwgbm9kZSk7XG4gIH1cblxuICBNdXN0YWNoZVN0YXRlbWVudChyYXdNdXN0YWNoZTogSGFuZGxlYmFyc0FTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICAgIGxldCB7IHRva2VuaXplciB9ID0gdGhpcztcblxuICAgIGlmICh0b2tlbml6ZXJbJ3N0YXRlJ10gPT09ICdjb21tZW50Jykge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShyYXdNdXN0YWNoZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBtdXN0YWNoZTogQVNULk11c3RhY2hlU3RhdGVtZW50O1xuICAgIGxldCB7IGVzY2FwZWQsIGxvYyB9ID0gcmF3TXVzdGFjaGU7XG5cbiAgICBpZiAocmF3TXVzdGFjaGUucGF0aC50eXBlLm1hdGNoKC9MaXRlcmFsJC8pKSB7XG4gICAgICBtdXN0YWNoZSA9IHtcbiAgICAgICAgdHlwZTogJ011c3RhY2hlU3RhdGVtZW50JyxcbiAgICAgICAgcGF0aDogdGhpcy5hY2NlcHROb2RlPEFTVC5MaXRlcmFsPihyYXdNdXN0YWNoZS5wYXRoKSxcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgaGFzaDogYi5oYXNoKCksXG4gICAgICAgIGVzY2FwZWQsXG4gICAgICAgIGxvYyxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKFxuICAgICAgICB0aGlzLFxuICAgICAgICByYXdNdXN0YWNoZSBhcyBIYW5kbGViYXJzQVNULk11c3RhY2hlU3RhdGVtZW50ICYge1xuICAgICAgICAgIHBhdGg6IEhhbmRsZWJhcnNBU1QuUGF0aEV4cHJlc3Npb247XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBtdXN0YWNoZSA9IGIubXVzdGFjaGUocGF0aCwgcGFyYW1zLCBoYXNoLCAhZXNjYXBlZCwgbG9jKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuaXplci5zdGF0ZSkge1xuICAgICAgLy8gVGFnIGhlbHBlcnNcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUudGFnTmFtZTpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZU5hbWU6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmFmdGVyQXR0cmlidXRlTmFtZTpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5maW5pc2hBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmFmdGVyQXR0cmlidXRlVmFsdWVRdW90ZWQ6XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gQXR0cmlidXRlIHZhbHVlc1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVWYWx1ZTpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgYXBwZW5kRHluYW1pY0F0dHJpYnV0ZVZhbHVlUGFydCh0aGlzLmN1cnJlbnRBdHRyaWJ1dGUhLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVVbnF1b3RlZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlZDpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZWQ6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlVW5xdW90ZWQ6XG4gICAgICAgIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQodGhpcy5jdXJyZW50QXR0cmlidXRlISwgbXVzdGFjaGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gVE9ETzogT25seSBhcHBlbmQgY2hpbGQgd2hlbiB0aGUgdG9rZW5pemVyIHN0YXRlIG1ha2VzXG4gICAgICAvLyBzZW5zZSB0byBkbyBzbywgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBtdXN0YWNoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG11c3RhY2hlO1xuICB9XG5cbiAgQ29udGVudFN0YXRlbWVudChjb250ZW50OiBIYW5kbGViYXJzQVNULkNvbnRlbnRTdGF0ZW1lbnQpIHtcbiAgICB1cGRhdGVUb2tlbml6ZXJMb2NhdGlvbih0aGlzLnRva2VuaXplciwgY29udGVudCk7XG5cbiAgICB0aGlzLnRva2VuaXplci50b2tlbml6ZVBhcnQoY29udGVudC52YWx1ZSk7XG4gICAgdGhpcy50b2tlbml6ZXIuZmx1c2hEYXRhKCk7XG4gIH1cblxuICBDb21tZW50U3RhdGVtZW50KFxuICAgIHJhd0NvbW1lbnQ6IEhhbmRsZWJhcnNBU1QuQ29tbWVudFN0YXRlbWVudFxuICApOiBPcHRpb248QVNULk11c3RhY2hlQ29tbWVudFN0YXRlbWVudD4ge1xuICAgIGxldCB7IHRva2VuaXplciB9ID0gdGhpcztcblxuICAgIGlmICh0b2tlbml6ZXIuc3RhdGUgPT09IFRva2VuaXplclN0YXRlLmNvbW1lbnQpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUocmF3Q29tbWVudCkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHsgdmFsdWUsIGxvYyB9ID0gcmF3Q29tbWVudDtcbiAgICBsZXQgY29tbWVudCA9IGIubXVzdGFjaGVDb21tZW50KHZhbHVlLCBsb2MpO1xuXG4gICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZTpcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRUYWcuY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlRGF0YTpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuZGF0YTpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgVXNpbmcgYSBIYW5kbGViYXJzIGNvbW1lbnQgd2hlbiBpbiB0aGUgXFxgJHtcbiAgICAgICAgICAgIHRva2VuaXplclsnc3RhdGUnXVxuICAgICAgICAgIH1cXGAgc3RhdGUgaXMgbm90IHN1cHBvcnRlZDogXCIke2NvbW1lbnQudmFsdWV9XCIgb24gbGluZSAke2xvYy5zdGFydC5saW5lfToke1xuICAgICAgICAgICAgbG9jLnN0YXJ0LmNvbHVtblxuICAgICAgICAgIH1gLFxuICAgICAgICAgIHJhd0NvbW1lbnQubG9jXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1lbnQ7XG4gIH1cblxuICBQYXJ0aWFsU3RhdGVtZW50KHBhcnRpYWw6IEhhbmRsZWJhcnNBU1QuUGFydGlhbFN0YXRlbWVudCkge1xuICAgIGxldCB7IGxvYyB9ID0gcGFydGlhbDtcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIHBhcnRpYWxzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKHBhcnRpYWwsIHBhcnRpYWwubmFtZSl9XCIgYXQgTCR7XG4gICAgICAgIGxvYy5zdGFydC5saW5lXG4gICAgICB9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIHBhcnRpYWwubG9jXG4gICAgKTtcbiAgfVxuXG4gIFBhcnRpYWxCbG9ja1N0YXRlbWVudChwYXJ0aWFsQmxvY2s6IEhhbmRsZWJhcnNBU1QuUGFydGlhbEJsb2NrU3RhdGVtZW50KSB7XG4gICAgbGV0IHsgbG9jIH0gPSBwYXJ0aWFsQmxvY2s7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFsIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgcGFydGlhbEJsb2NrLFxuICAgICAgICBwYXJ0aWFsQmxvY2submFtZVxuICAgICAgKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLFxuICAgICAgcGFydGlhbEJsb2NrLmxvY1xuICAgICk7XG4gIH1cblxuICBEZWNvcmF0b3IoZGVjb3JhdG9yOiBIYW5kbGViYXJzQVNULkRlY29yYXRvcikge1xuICAgIGxldCB7IGxvYyB9ID0gZGVjb3JhdG9yO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgZGVjb3JhdG9ycyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgZGVjb3JhdG9yLFxuICAgICAgICBkZWNvcmF0b3IucGF0aFxuICAgICAgKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLFxuICAgICAgZGVjb3JhdG9yLmxvY1xuICAgICk7XG4gIH1cblxuICBEZWNvcmF0b3JCbG9jayhkZWNvcmF0b3JCbG9jazogSGFuZGxlYmFyc0FTVC5EZWNvcmF0b3JCbG9jaykge1xuICAgIGxldCB7IGxvYyB9ID0gZGVjb3JhdG9yQmxvY2s7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBkZWNvcmF0b3IgYmxvY2tzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKFxuICAgICAgICBkZWNvcmF0b3JCbG9jayxcbiAgICAgICAgZGVjb3JhdG9yQmxvY2sucGF0aFxuICAgICAgKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLFxuICAgICAgZGVjb3JhdG9yQmxvY2subG9jXG4gICAgKTtcbiAgfVxuXG4gIFN1YkV4cHJlc3Npb24oc2V4cHI6IEhhbmRsZWJhcnNBU1QuU3ViRXhwcmVzc2lvbik6IEFTVC5TdWJFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBzZXhwcik7XG4gICAgcmV0dXJuIGIuc2V4cHIocGF0aCwgcGFyYW1zLCBoYXNoLCBzZXhwci5sb2MpO1xuICB9XG5cbiAgUGF0aEV4cHJlc3Npb24ocGF0aDogSGFuZGxlYmFyc0FTVC5QYXRoRXhwcmVzc2lvbik6IEFTVC5QYXRoRXhwcmVzc2lvbiB7XG4gICAgbGV0IHsgb3JpZ2luYWwsIGxvYyB9ID0gcGF0aDtcbiAgICBsZXQgcGFydHM6IHN0cmluZ1tdO1xuXG4gICAgaWYgKG9yaWdpbmFsLmluZGV4T2YoJy8nKSAhPT0gLTEpIHtcbiAgICAgIGlmIChvcmlnaW5hbC5zbGljZSgwLCAyKSA9PT0gJy4vJykge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVzaW5nIFwiLi9cIiBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXIgYW5kIHVubmVjZXNzYXJ5OiBcIiR7cGF0aC5vcmlnaW5hbH1cIiBvbiBsaW5lICR7XG4gICAgICAgICAgICBsb2Muc3RhcnQubGluZVxuICAgICAgICAgIH0uYCxcbiAgICAgICAgICBwYXRoLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDMpID09PSAnLi4vJykge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYENoYW5naW5nIGNvbnRleHQgdXNpbmcgXCIuLi9cIiBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXI6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtcbiAgICAgICAgICAgIGxvYy5zdGFydC5saW5lXG4gICAgICAgICAgfS5gLFxuICAgICAgICAgIHBhdGgubG9jXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYE1peGluZyAnLicgYW5kICcvJyBpbiBwYXRocyBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXI7IHVzZSBvbmx5ICcuJyB0byBzZXBhcmF0ZSBwcm9wZXJ0eSBwYXRoczogXCIke1xuICAgICAgICAgICAgcGF0aC5vcmlnaW5hbFxuICAgICAgICAgIH1cIiBvbiBsaW5lICR7bG9jLnN0YXJ0LmxpbmV9LmAsXG4gICAgICAgICAgcGF0aC5sb2NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzID0gW3BhdGgucGFydHMuam9pbignLycpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMgPSBwYXRoLnBhcnRzO1xuICAgIH1cblxuICAgIGxldCB0aGlzSGVhZCA9IGZhbHNlO1xuXG4gICAgLy8gVGhpcyBpcyB0byBmaXggYSBidWcgaW4gdGhlIEhhbmRsZWJhcnMgQVNUIHdoZXJlIHRoZSBwYXRoIGV4cHJlc3Npb25zIGluXG4gICAgLy8gYHt7dGhpcy5mb299fWAgKGFuZCBzaW1pbGFybHkgYHt7Zm9vLWJhciB0aGlzLmZvbyBuYW1lZD10aGlzLmZvb319YCBldGMpXG4gICAgLy8gYXJlIHNpbXBseSB0dXJuZWQgaW50byBge3tmb299fWAuIFRoZSBmaXggaXMgdG8gcHVzaCBpdCBiYWNrIG9udG8gdGhlXG4gICAgLy8gcGFydHMgYXJyYXkgYW5kIGxldCB0aGUgcnVudGltZSBzZWUgdGhlIGRpZmZlcmVuY2UuIEhvd2V2ZXIsIHdlIGNhbm5vdFxuICAgIC8vIHNpbXBseSB1c2UgdGhlIHN0cmluZyBgdGhpc2AgYXMgaXQgbWVhbnMgbGl0ZXJhbGx5IHRoZSBwcm9wZXJ0eSBjYWxsZWRcbiAgICAvLyBcInRoaXNcIiBpbiB0aGUgY3VycmVudCBjb250ZXh0IChpdCBjYW4gYmUgZXhwcmVzc2VkIGluIHRoZSBzeW50YXggYXNcbiAgICAvLyBge3tbdGhpc119fWAsIHdoZXJlIHRoZSBzcXVhcmUgYnJhY2tldCBhcmUgZ2VuZXJhbGx5IGZvciB0aGlzIGtpbmQgb2ZcbiAgICAvLyBlc2NhcGluZyDigJMgc3VjaCBhcyBge3tmb28uW1wiYmFyLmJhelwiXX19YCB3b3VsZCBtZWFuIGxvb2t1cCBhIHByb3BlcnR5XG4gICAgLy8gbmFtZWQgbGl0ZXJhbGx5IFwiYmFyLmJhelwiIG9uIGB0aGlzLmZvb2ApLiBCeSBjb252ZW50aW9uLCB3ZSB1c2UgYG51bGxgXG4gICAgLy8gZm9yIHRoaXMgcHVycG9zZS5cbiAgICBpZiAob3JpZ2luYWwubWF0Y2goL150aGlzKFxcLi4rKT8kLykpIHtcbiAgICAgIHRoaXNIZWFkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1BhdGhFeHByZXNzaW9uJyxcbiAgICAgIG9yaWdpbmFsOiBwYXRoLm9yaWdpbmFsLFxuICAgICAgdGhpczogdGhpc0hlYWQsXG4gICAgICBwYXJ0cyxcbiAgICAgIGRhdGE6IHBhdGguZGF0YSxcbiAgICAgIGxvYzogcGF0aC5sb2MsXG4gICAgfTtcbiAgfVxuXG4gIEhhc2goaGFzaDogSGFuZGxlYmFyc0FTVC5IYXNoKTogQVNULkhhc2gge1xuICAgIGxldCBwYWlyczogQVNULkhhc2hQYWlyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaC5wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhaXIgPSBoYXNoLnBhaXJzW2ldO1xuICAgICAgcGFpcnMucHVzaChiLnBhaXIocGFpci5rZXksIHRoaXMuYWNjZXB0Tm9kZTxBU1QuRXhwcmVzc2lvbj4ocGFpci52YWx1ZSksIHBhaXIubG9jKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuaGFzaChwYWlycywgaGFzaC5sb2MpO1xuICB9XG5cbiAgU3RyaW5nTGl0ZXJhbChzdHJpbmc6IEhhbmRsZWJhcnNBU1QuU3RyaW5nTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnLCBzdHJpbmcudmFsdWUsIHN0cmluZy5sb2MpO1xuICB9XG5cbiAgQm9vbGVhbkxpdGVyYWwoYm9vbGVhbjogSGFuZGxlYmFyc0FTVC5Cb29sZWFuTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ0Jvb2xlYW5MaXRlcmFsJywgYm9vbGVhbi52YWx1ZSwgYm9vbGVhbi5sb2MpO1xuICB9XG5cbiAgTnVtYmVyTGl0ZXJhbChudW1iZXI6IEhhbmRsZWJhcnNBU1QuTnVtYmVyTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bWJlckxpdGVyYWwnLCBudW1iZXIudmFsdWUsIG51bWJlci5sb2MpO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbCh1bmRlZjogSGFuZGxlYmFyc0FTVC5VbmRlZmluZWRMaXRlcmFsKSB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCwgdW5kZWYubG9jKTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKG51bDogSGFuZGxlYmFyc0FTVC5OdWxsTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bGxMaXRlcmFsJywgbnVsbCwgbnVsLmxvYyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMob3JpZ2luYWw6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgLy8gaWYgaXQgaXMgZW1wdHksIGp1c3QgcmV0dXJuIHRoZSBjb3VudCBvZiBuZXdsaW5lc1xuICAgIC8vIGluIG9yaWdpbmFsXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVzOiBvcmlnaW5hbC5zcGxpdCgnXFxuJykubGVuZ3RoIC0gMSxcbiAgICAgIGNvbHVtbnM6IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgbmV3bGluZXMgcHJpb3IgdG9cbiAgLy8gYHZhbHVlYFxuICBsZXQgZGlmZmVyZW5jZSA9IG9yaWdpbmFsLnNwbGl0KHZhbHVlKVswXTtcbiAgbGV0IGxpbmVzID0gZGlmZmVyZW5jZS5zcGxpdCgvXFxuLyk7XG4gIGxldCBsaW5lQ291bnQgPSBsaW5lcy5sZW5ndGggLSAxO1xuXG4gIHJldHVybiB7XG4gICAgbGluZXM6IGxpbmVDb3VudCxcbiAgICBjb2x1bW5zOiBsaW5lc1tsaW5lQ291bnRdLmxlbmd0aCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVG9rZW5pemVyTG9jYXRpb24oXG4gIHRva2VuaXplcjogUGFyc2VyWyd0b2tlbml6ZXInXSxcbiAgY29udGVudDogSGFuZGxlYmFyc0FTVC5Db250ZW50U3RhdGVtZW50XG4pIHtcbiAgbGV0IGxpbmUgPSBjb250ZW50LmxvYy5zdGFydC5saW5lO1xuICBsZXQgY29sdW1uID0gY29udGVudC5sb2Muc3RhcnQuY29sdW1uO1xuXG4gIGxldCBvZmZzZXRzID0gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMoXG4gICAgY29udGVudC5vcmlnaW5hbCBhcyBSZWNhc3Q8SGFuZGxlYmFyc0FTVC5TdHJpcEZsYWdzLCBzdHJpbmc+LFxuICAgIGNvbnRlbnQudmFsdWVcbiAgKTtcblxuICBsaW5lID0gbGluZSArIG9mZnNldHMubGluZXM7XG4gIGlmIChvZmZzZXRzLmxpbmVzKSB7XG4gICAgY29sdW1uID0gb2Zmc2V0cy5jb2x1bW5zO1xuICB9IGVsc2Uge1xuICAgIGNvbHVtbiA9IGNvbHVtbiArIG9mZnNldHMuY29sdW1ucztcbiAgfVxuXG4gIHRva2VuaXplci5saW5lID0gbGluZTtcbiAgdG9rZW5pemVyLmNvbHVtbiA9IGNvbHVtbjtcbn1cblxuZnVuY3Rpb24gYWNjZXB0Q2FsbE5vZGVzKFxuICBjb21waWxlcjogSGFuZGxlYmFyc05vZGVWaXNpdG9ycyxcbiAgbm9kZToge1xuICAgIHBhdGg6IEhhbmRsZWJhcnNBU1QuUGF0aEV4cHJlc3Npb247XG4gICAgcGFyYW1zOiBIYW5kbGViYXJzQVNULkV4cHJlc3Npb25bXTtcbiAgICBoYXNoOiBIYW5kbGViYXJzQVNULkhhc2g7XG4gIH1cbik6IHsgcGF0aDogQVNULlBhdGhFeHByZXNzaW9uOyBwYXJhbXM6IEFTVC5FeHByZXNzaW9uW107IGhhc2g6IEFTVC5IYXNoIH0ge1xuICBsZXQgcGF0aCA9IGNvbXBpbGVyLlBhdGhFeHByZXNzaW9uKG5vZGUucGF0aCk7XG5cbiAgbGV0IHBhcmFtcyA9IG5vZGUucGFyYW1zID8gbm9kZS5wYXJhbXMubWFwKGUgPT4gY29tcGlsZXIuYWNjZXB0Tm9kZTxBU1QuRXhwcmVzc2lvbj4oZSkpIDogW107XG4gIGxldCBoYXNoID0gbm9kZS5oYXNoID8gY29tcGlsZXIuSGFzaChub2RlLmhhc2gpIDogYi5oYXNoKCk7XG5cbiAgcmV0dXJuIHsgcGF0aCwgcGFyYW1zLCBoYXNoIH07XG59XG5cbmZ1bmN0aW9uIGFkZEVsZW1lbnRNb2RpZmllcihlbGVtZW50OiBUYWc8J1N0YXJ0VGFnJz4sIG11c3RhY2hlOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoLCBsb2MgfSA9IG11c3RhY2hlO1xuXG4gIGlmIChpc0xpdGVyYWwocGF0aCkpIHtcbiAgICBsZXQgbW9kaWZpZXIgPSBge3ske3ByaW50TGl0ZXJhbChwYXRoKX19fWA7XG4gICAgbGV0IHRhZyA9IGA8JHtlbGVtZW50Lm5hbWV9IC4uLiAke21vZGlmaWVyfSAuLi5gO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEluICR7dGFnfSwgJHttb2RpZmllcn0gaXMgbm90IGEgdmFsaWQgbW9kaWZpZXI6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2MgJiZcbiAgICAgICAgbG9jLnN0YXJ0LmxpbmV9LmAsXG4gICAgICBtdXN0YWNoZS5sb2NcbiAgICApO1xuICB9XG5cbiAgbGV0IG1vZGlmaWVyID0gYi5lbGVtZW50TW9kaWZpZXIocGF0aCwgcGFyYW1zLCBoYXNoLCBsb2MpO1xuICBlbGVtZW50Lm1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbn1cblxuZnVuY3Rpb24gYWRkSW5FbGVtZW50SGFzaChjdXJzb3I6IHN0cmluZywgaGFzaDogQVNULkhhc2gsIGxvYzogQVNULlNvdXJjZUxvY2F0aW9uKSB7XG4gIGxldCBoYXNOZXh0U2libGluZyA9IGZhbHNlO1xuICBoYXNoLnBhaXJzLmZvckVhY2gocGFpciA9PiB7XG4gICAgaWYgKHBhaXIua2V5ID09PSAnZ3VpZCcpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ2Fubm90IHBhc3MgYGd1aWRgIGZyb20gdXNlciBzcGFjZScsIGxvYyk7XG4gICAgfVxuXG4gICAgaWYgKHBhaXIua2V5ID09PSAnbmV4dFNpYmxpbmcnKSB7XG4gICAgICBoYXNOZXh0U2libGluZyA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBsZXQgZ3VpZCA9IGIubGl0ZXJhbCgnU3RyaW5nTGl0ZXJhbCcsIGN1cnNvcik7XG4gIGxldCBndWlkUGFpciA9IGIucGFpcignZ3VpZCcsIGd1aWQpO1xuICBoYXNoLnBhaXJzLnVuc2hpZnQoZ3VpZFBhaXIpO1xuXG4gIGlmICghaGFzTmV4dFNpYmxpbmcpIHtcbiAgICBsZXQgbnVsbExpdGVyYWwgPSBiLmxpdGVyYWwoJ051bGxMaXRlcmFsJywgbnVsbCk7XG4gICAgbGV0IG5leHRTaWJsaW5nID0gYi5wYWlyKCduZXh0U2libGluZycsIG51bGxMaXRlcmFsKTtcbiAgICBoYXNoLnBhaXJzLnB1c2gobmV4dFNpYmxpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQoYXR0cmlidXRlOiBBdHRyaWJ1dGUsIHBhcnQ6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICBhdHRyaWJ1dGUuaXNEeW5hbWljID0gdHJ1ZTtcbiAgYXR0cmlidXRlLnBhcnRzLnB1c2gocGFydCk7XG59XG4iXX0=